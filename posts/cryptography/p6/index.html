<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Cryptography 6: Can't predict the next bit? Your PRG is secure! - Daminha Blog</title>
<meta name=description content="This sixth blog in the Cryptography Series explores two fundamental ideas regarding Pseudorandom Generators (PRGs). First, we will learn about the Blum-Micali method, an intelligent sequential construction that allows us to build a PRG capable of extending its output to an arbitrary length from a base PRG that only stretches its input slightly. Next, the post introduces a core security standard: next-bit unpredictability. The highlight of this post is the proof of a classic and surprising result: a PRG is considered secure (indistinguishable from a truly random sequence) if and only if no adversary can efficiently predict its next bit. This provides a solid bridge between statistical theory and practical predictability."><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Daminha Blog","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p6\/","name":"Cryptography 6 can\u0027t predict the next bit? your prg is secure!"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Dang Duong Minh Nhat"},"headline":"Cryptography 6: Can\u0027t predict the next bit? Your PRG is secure!","description":"This sixth blog in the Cryptography Series explores two fundamental ideas regarding Pseudorandom Generators (PRGs). First, we will learn about the Blum-Micali method, an intelligent sequential construction that allows us to build a PRG capable of extending its output to an arbitrary length from a base PRG that only stretches its input slightly. Next, the post introduces a core security standard: next-bit unpredictability. The highlight of this post is the proof of a classic and surprising result: a PRG is considered secure (indistinguishable from a truly random sequence) if and only if no adversary can efficiently predict its next bit. This provides a solid bridge between statistical theory and practical predictability.","inLanguage":"en","wordCount":2834,"datePublished":"2025-08-19T13:50:00\u002b07:00","dateModified":"2025-08-19T13:50:00\u002b07:00","image":"https:\/\/dangduongminhnhat.github.io\/","keywords":["Cryptography, Pseudo-random Generator, Blum-Micali, Next-Bit Test"],"mainEntityOfPage":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p6\/","publisher":{"@type":"Organization","name":"https:\/\/dangduongminhnhat.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/dangduongminhnhat.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Cryptography 6: Can't predict the next bit? Your PRG is secure!"><meta property="og:description" content="This sixth blog in the Cryptography Series explores two fundamental ideas regarding Pseudorandom Generators (PRGs). First, we will learn about the Blum-Micali method, an intelligent sequential construction that allows us to build a PRG capable of extending its output to an arbitrary length from a base PRG that only stretches its input slightly. Next, the post introduces a core security standard: next-bit unpredictability. The highlight of this post is the proof of a classic and surprising result: a PRG is considered secure (indistinguishable from a truly random sequence) if and only if no adversary can efficiently predict its next bit. This provides a solid bridge between statistical theory and practical predictability."><meta property="og:url" content="https://dangduongminhnhat.github.io/posts/cryptography/p6/"><meta property="og:type" content="website"><meta property="og:site_name" content="Daminha Blog"><meta name=twitter:title content="Cryptography 6: Can't predict the next bit? Your PRG is secure!"><meta name=twitter:description content="This sixth blog in the Cryptography Series explores two fundamental ideas regarding Pseudorandom Generators (PRGs). First, we will learn about the Blum-Micali method, an intelligent sequential …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.129.0"><link rel=alternate href=https://dangduongminhnhat.github.io/index.xml type=application/rss+xml title="Daminha Blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/syntax.css><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/theme-toggle.css><script>const savedTheme=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",savedTheme)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-V19WW5WSEZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-V19WW5WSEZ")}</script><link rel=apple-touch-icon sizes=180x180 href=/favicon_io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon_io/favicon-16x16.png><link rel=manifest href=/favicon_io/site.webmanifest><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      processEscapes: true
    }
  });
</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=google-site-verification content="ors8seNeA2TL4hvELynbBtrr4PwXapoPh2td6zTadCU"><meta name=google-site-verification content="oQJmyNtEP9HjjEcXwRno2_YPeuLd5kX3jTltynIx65s"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://dangduongminhnhat.github.io/>Daminha Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=About href=/posts/about-me/>About</a></li><li><a title=Tags href=/tags/>Tags</a></li><li><a title="Cryptography Series" href=/posts/cryptography/>Cryptography Series</a></li><li><a title=Note href=https://hackmd.io/@daminha>Note</a></li><li><a title=Blog href=/posts/blog/>Blog</a></li><li><a href=javascript:void(0); onclick=toggleTheme() style=outline:none><span class="hidden-sm hidden-md hidden-lg">Theme</span>
<span class="glyphicon glyphicon-adjust" id=themeGlyph></span></a></li></ul></div></div></nav><script>document.addEventListener("DOMContentLoaded",function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e),window.toggleTheme=function(){const t=document.documentElement.getAttribute("data-theme"),e=t==="dark"?"light":"dark";document.documentElement.setAttribute("data-theme",e),localStorage.setItem("theme",e)}})</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=posts-heading><h1>Cryptography 6: Can't predict the next bit? Your PRG is secure!</h1><hr class=small></div></div></div></div></div><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p><strong>Posted on:</strong> August 19, 2025 |
<strong>Reading time:</strong> 14 minutes |
<strong>Word count:</strong> 2834 words |
<strong>Author:</strong> Dang Duong Minh Nhat</p><p>Hello everyone, welcome back!
We now continue with episode 6 of this series. In this installment, we’ll dive into some of the more difficult (and interesting) topics: the Blum–Micali sequential construction and the hardness of predicting the next bit of a PRG.</p><p>To get the most out of this post, I highly recommend you first read <a href=https://dangduongminhnhat.github.io/posts/cryptography/p5/>episode 5</a> and the other articles in <a href=https://dangduongminhnhat.github.io/posts/cryptography/>this series</a> to build the right background.</p><p>Alright — let’s get started!</p><hr><h2 id=a-sequential-construction-the-blum-micali-method>A Sequential Construction: The Blum-Micali Method</h2><p>Okay, let&rsquo;s start with a sequential construction method, invented by Blum and Micali, which uses a pseudorandom generator (PRG) with a small stretch to build a PRG that can stretch to an arbitrary length.</p><p>Suppose $G$ is a PRG defined on $(\mathcal{S}, \mathcal{R} \times \mathcal{S})$, where $\mathcal{S}$ and $\mathcal{R}$ are two finite sets. For any polynomially bounded value $n \ge 1$, we can construct a new PRG $G&rsquo;$ defined on $(\mathcal{S}, \mathcal{R}^n \times \mathcal{S})$. For $s \in \mathcal{S}$, we define:</p><p>$$
\begin{aligned}
G&rsquo;(s) & := \\
& s_0 \leftarrow s\\
& \text{for } i \leftarrow 1 \text{ to } n \text{ do}\\
&\qquad (r_i,s_i) \leftarrow G(s_{i-1})\\
& \text{output } (r_1,\ldots,r_n,s_n).
\end{aligned}
$$</p><p>We call $G&rsquo;$ the <strong>n-fold sequential composition</strong> of $G$.</p><p><img src=/images/cryptography/p6/the_sequential_construction.png alt=image>
<strong>Figure 1:</strong> The sequential construction with $n = 3$</p><p>We will prove in <strong>Theorem 1</strong> that if $G$ is a secure PRG, then $G&rsquo;$ is also a secure PRG. A special case of this construction is as follows: suppose $G$ is a PRG defined on $(\left\lbrace 0,1\right\rbrace^\ell, \left\lbrace 0,1\right\rbrace^{t+\ell})$, where $\ell$ and $t$ are positive integers; that is, $G$ stretches an $\ell$-bit string into a $(t + \ell)$-bit string. We can view the output space of $G$ as $\left\lbrace 0,1\right\rbrace^t \times \left\lbrace 0,1\right\rbrace^\ell$, and by applying the above structure and interpreting the output as a bit string, we get a PRG $G&rsquo;$ that stretches an $\ell$-bit string into an $(nt + \ell)$-bit string.</p><hr><p><strong>Theorem 1.</strong> If $G$ is a secure PRG, then its n-fold sequential composition $G&rsquo;$ is also a secure PRG.</p><p>Specifically, for any PRG adversary $\mathcal{A}$ participating in the <strong>PRG Attack Game</strong> against $G&rsquo;$, there exists a PRG adversary $\mathcal{B}$ participating in the <strong>PRG Attack Game</strong> against $G$, where $\mathcal{B}$ is simply a wrapper around $\mathcal{A}$, such that:</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{A}, G&rsquo;] = n \cdot \mathtt{PRG}\text{adv}[\mathcal{B}, G].
$$</p><hr><p><strong>Proof.</strong> Let $\mathcal{A}$ be a PRG adversary participating in the <strong>PRG Attack Game</strong> against $G&rsquo;$. We define a sequence of hybrid games, called Hybrid $0$, Hybrid $1$, &mldr;, Hybrid $n$. For $j = 0, 1, &mldr;, n$, Hybrid $j$ is defined as a game between $\mathcal{A}$ and a challenger as follows:</p><p>$$
\begin{aligned}
& r_1 \xleftarrow{R} \mathcal{R}\\
& \vdots \\
& r_j \xleftarrow{R} \mathcal{R}\\
& s_j \xleftarrow{R} \mathcal{S}\\
& (r_{j+1},s_{j+1}) \leftarrow G(s_j)\\
& \vdots \\
& (r_n,s_n) \leftarrow G(s_{n-1})\\
& \text{send } (r_1,\ldots,r_n,s_n) \text{ to } \mathcal{A}.
\end{aligned}
$$</p><p>As usual, $\mathcal{A}$ will output $0$ or $1$ at the end of the game.</p><p><img src=/images/cryptography/p6/hybrid_games.png alt=image>
<strong>Figure 2:</strong> The challenger&rsquo;s computation in the hybrid games with $n = 3$. Circles denote elements randomly generated from the set $\mathcal{S}$ or $\mathcal{R}$, as labeled.</p><p>Let $p_j$ be the probability that $\mathcal{A}$ outputs $1$ in Hybrid $j$. Note that $p_0$ is the probability that $\mathcal{A}$ outputs $1$ in <strong>Experiment 0</strong> and $p_n$ is the probability that $\mathcal{A}$ outputs $1$ in <strong>Experiment 1</strong> of the PRG Attack Game. Therefore, we have:</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{A}, G&rsquo;] = |p_n - p_0| \quad \tag{1}
$$</p><hr><p>We next define a PRG adversary $\mathcal{B}$ participating in the <strong>PRG Attack Game</strong> against $G$, which operates as follows:</p><ul><li>Upon receiving $(r, s) \in \mathcal{R} \times \mathcal{S}$ from its challenger, $\mathcal{B}$ acts as a challenger for $\mathcal{A}$ as follows:</li></ul><p>$$
\begin{aligned}
& \omega \xleftarrow{R} \left\lbrace 1,\ldots,n\right\rbrace \\
& r_1 \xleftarrow{R} \mathcal{R}, \ldots , r_{\omega-1} \xleftarrow{R} \mathcal{R} \\
& (r_{\omega}, s_{\omega}) \leftarrow (r,s) \\
& (r_{\omega+1}, s_{\omega+1}) \leftarrow G(s_{\omega}),\ldots, (r_{n}, s_{n}) \leftarrow G(s_{n-1}) \\
& \text{send } (r_1,\ldots,r_n,s_n) \text{ to } \mathcal{A}.
\end{aligned}
$$</p><ul><li>Finally, $\mathcal{B}$ outputs whatever $A$ outputs.</li></ul><p>Let $W_0$ be the event that $B$ outputs 1 in <strong>Experiment 0</strong>, and $W_1$ be the event that $B$ outputs 1 in <strong>Experiment 1</strong> of the PRG Attack Game.</p><p>The <strong>key observation</strong> is:</p><blockquote><p>For each $j = 1, &mldr;, n$, conditioning on $ω = j$ makes <strong>Experiment 0</strong> for $\mathcal{B}$ equivalent to <strong>Hybrid $j-1$</strong>, and <strong>Experiment 1</strong> for $\mathcal{B}$ equivalent to <strong>Hybrid $j$</strong>.</p></blockquote><p>Therefore:</p><p>$$
\Pr[W_0 \mid ω = j] = p_{j-1} \quad \text{and} \quad \Pr[W_1 \mid ω = j] = p_j
$$</p><p>The rest of the proof is a simple calculation, identical to the final part of the proof of Theorem 1 in the <a href=https://dangduongminhnhat.github.io/posts/cryptography/p5/>Cryptography 5</a> post. ✷</p><hr><p>One criterion for evaluating a PRG is its <strong>expansion rate</strong>: a PRG that stretches an $n$-bit seed into an $m$-bit output has an expansion rate of $m/n$; more generally, if the seed space is $\mathcal{S}$ and the output space is $\mathcal{R}$, the expansion rate is defined as $\log |\mathcal{R}| / \log |\mathcal{S}|$. The sequential construction achieves a better expansion rate than a parallel construction. However, it has the disadvantage of <strong>not being parallelizable</strong>.</p><hr><h2 id=the-next-bit-test>The Next-Bit Test</h2><p>Suppose $G$ is a PRG defined on $(\left\lbrace 0,1\right\rbrace^{\ell},\left\lbrace 0,1\right\rbrace^{L})$, meaning it expands an $\ell$-bit string into an $L$-bit string. There are many ways an adversary could distinguish the pseudorandom output of $G$ from a truly random bit string. Indeed, suppose an efficient adversary could compute, for instance, the <strong>last bit</strong> of $G$&rsquo;s output, given the first $L - 1$ bits. The existence of such an adversary would render $G$ <strong>insecure</strong>, because given the first $L - 1$ bits of a <strong>truly random</strong> $L$-bit string, the chance of guessing the last bit correctly should be just $50$–$50$.</p><p>We will <strong>formally</strong> define the notion of <em>unpredictability</em> for a PRG; in essence, this means that: <strong>for an adversary-chosen index $i$, given the first $i$ bits of $G$&rsquo;s output, it is hard to predict the next bit (i.e., the $(i+1)$-th bit) with a probability significantly better than $1/2$</strong>. We will then prove that <em>unpredictability</em> and <em>security</em> are equivalent concepts. That security $\Rightarrow$ unpredictability is quite clear: if one can efficiently predict the next bit of a pseudorandom sequence, this immediately provides an effective statistical test. However, proving the reverse direction (<em>unpredictability $\Rightarrow$ security</em>) is much more interesting (and more difficult): this result states that <strong>if any efficient statistical test exists, then an efficient method for predicting the next bit in the pseudorandom sequence must also exist.</strong></p><hr><p><strong>The Attack Game (PRG Unpredictability).</strong> For a PRG $G$ (defined on $(\mathcal{S}, \left\lbrace 0,1\right\rbrace^L)$) and an adversary $\mathcal{A}$, the attack game proceeds as follows:</p><ul><li><p>The adversary sends an index $i$, with $0 \le i \le L-1$, to the challenger.</p></li><li><p>The challenger generates:</p><p>$$
s \xleftarrow{R} \mathcal{S},\quad r \leftarrow G(s),
$$</p><p>and sends $r[0 \dots i-1]$ to the adversary.</p></li><li><p>The adversary outputs a bit $g \in \left\lbrace 0,1\right\rbrace$.</p></li></ul><p>We say that $\mathcal{A}$ <em>wins</em> if $r[i] = g$, and we define the advantage of $A$:</p><p>$$
\mathtt{Pred}\text{adv}[\mathcal{A},G] := \bigl| \Pr[\mathcal{A} \text{ wins}] - 1/2 \bigr|.
$$</p><p>$\square$</p><hr><p><strong>Definition (Unpredictable PRG).</strong> A PRG $G$ is called <em>unpredictable</em> if $\mathtt{Pred}\text{adv}[\mathcal{A},G]$ is <strong>negligible</strong> for all efficient adversaries $\mathcal{A}$.</p><hr><p>We begin by proving that <em>security</em> $\Rightarrow$ <em>unpredictability</em>.</p><p><strong>Theorem 2.</strong> Let $G$ be a PRG defined on $(\mathcal{S},\left\lbrace 0,1\right\rbrace^L)$. If $G$ is secure, then $G$ is <em>unpredictable</em>. More specifically, for every adversary $\mathcal{A}$ that breaks the unpredictability of $G$ in the Unpredictable PRG Game, there exists an adversary $\mathcal{B}$ that breaks the security of $G$ (in the PRG Game), such that $\mathcal{B}$ is just a simple wrapper around $\mathcal{A}$, and:</p><p>$$
\mathtt{Pred}\text{adv}[\mathcal{A},G] = \mathtt{PRG}\text{adv}[\mathcal{B},G].
$$</p><p><em>Proof.</em> Let $\mathcal{A}$ be an adversary that breaks the unpredictability of $G$, and let $i$ be the index that $\mathcal{A}$ outputs. Assume $A$ wins the Unpredictable PRG Game with probability $1/2 + \varepsilon$, i.e., $\mathtt{Pred}\text{adv}[\mathcal{A},G] = |\varepsilon|$. We construct an adversary $\mathcal{B}$ that breaks the security of $G$ as follows:</p><ul><li><p>Upon receiving $r \in \left\lbrace 0,1\right\rbrace^L$ from its challenger, $\mathcal{B}$ does the following:</p><ul><li>It gives $r[0 \dots i-1]$ to $\mathcal{A}$ and receives a guess $g \in \left\lbrace 0,1\right\rbrace$.</li><li>If $r[i] = g$, $\mathcal{B}$ outputs $1$; otherwise, it outputs $0$.</li></ul></li></ul><p>Let $W_b$ be the event that $\mathcal{B}$ outputs $1$ in Experiment $b$ of the PRG Game ($b \in \left\lbrace 0,1\right\rbrace$).</p><ul><li><p>In Experiment 0: $r$ is a <strong>pseudorandom</strong> output, so</p><p>$$
\Pr[W_0] = 1/2 + \varepsilon.
$$</p></li><li><p>In Experiment 1: $r$ is a <strong>truly random</strong> string, but $r[i]$ and $g$ are independent, so</p><p>$$
\Pr[W_1] = 1/2.
$$</p></li></ul><p>Therefore:</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{B},G] = |\Pr[W_1] - \Pr[W_0]| = |\varepsilon| = \mathtt{Pred}\text{adv}[\mathcal{A},G].
\quad \square
$$</p><hr><p>The more interesting (and difficult) task is to prove the converse: <em>unpredictability $\Rightarrow$ security</em>. Before diving into the details of the proof, let&rsquo;s sketch the high-level ideas:</p><p>First, we use a <strong>hybrid argument</strong>, which allows us to argue that if $\mathcal{A}$ can efficiently distinguish an $L$-bit pseudorandom string from an $L$-bit random string, then we can construct an efficient adversary $\mathcal{B}$ that can distinguish</p><p>$$
x_1 \cdots x_j x_{j+1}
\quad\text{from}\quad
x_1 \cdots x_j r,
$$</p><p>where $j$ is a randomly chosen index, $x_1, \ldots, x_L$ are the pseudorandom outputs, and $r$ is a random bit. Thus, the adversary $\mathcal{B}$ can distinguish the pseudorandom bit $x_{j+1}$ from the random bit $r$, given the prefix string $x_1, \ldots, x_j$.</p><p>The final goal is to turn this distinguishing advantage into a <strong>predicting advantage</strong>. The rough idea is as follows:
Given $x_1, \ldots, x_j$, we feed the adversary $\mathcal{B}$ the string $x_1, \ldots, x_j r$ where $r$ is randomly chosen.</p><ul><li>If $\mathcal{B}$ outputs $1$, we guess $x_{j+1} = r$;</li><li>If $\mathcal{B}$ outputs $0$, we guess $x_{j+1} = \overline{r}$.</li></ul><hr><p>The fact that this prediction strategy works is due to the following general result, which we call the <strong>distinguisher/predictor lemma</strong>. The general setup is as follows:</p><ul><li><p>$\mathbf{X}$ is a random variable, corresponding to the &ldquo;side information&rdquo; $x_1,\ldots,x_j$ above, as well as all the random coins used by the adversary $\mathcal{B}$;</p></li><li><p>$\mathbf{B}$ is a $0/1$-valued random variable, corresponding to $x_{j+1}$, which <strong>may depend</strong> on $\mathbf{X}$;</p></li><li><p>$\mathbf{R}$ is a $0/1$-valued random variable, corresponding to $r$ above, which is <strong>independent</strong> of $(\mathbf{X},\mathbf{B})$;</p></li><li><p>$d$ is a function, corresponding to $\mathcal{B}$&rsquo;s strategy, such that $\mathcal{B}$&rsquo;s distinguishing advantage is $|\varepsilon|$, where</p><p>$$
\varepsilon = \Pr[d(\mathbf{X},\mathbf{B}) = 1] - \Pr[d(\mathbf{X},\mathbf{R}) = 1].
$$</p></li></ul><p>The lemma states that if we define the predictor variable $\mathbf{B}&rsquo;$ according to the strategy above, specifically:</p><p>$$
\mathbf{B}&rsquo; =
\begin{cases}
\mathbf{R}, & \text{if } d(\mathbf{X},\mathbf{R}) = 1;\
\overline{\mathbf{R}}, & \text{if } d(\mathbf{X},\mathbf{R}) = 0,
\end{cases}
$$</p><p>then the <strong>probability</strong> that $\mathbf{B}&rsquo;$ equals the true value $\mathbf{B}$ is precisely $1/2 + \varepsilon$. Here is the formal statement of the lemma:</p><hr><p><strong>Lemma (Distinguisher/predictor lemma).</strong> Let $\mathbf{X}$ be a random variable taking values in a set $S$, and let $\mathbf{B}, \mathbf{R}$ be $0/1$-valued random variables, where $\mathbf{R}$ is uniformly distributed on $\left\lbrace 0,1\right\rbrace$ and <strong>independent</strong> of $(\mathbf{X},\mathbf{B})$. Let $d : S \times \left\lbrace 0,1\right\rbrace \to \left\lbrace 0,1\right\rbrace$ be an arbitrary function, and set</p><p>$$
\varepsilon := \Pr[d(\mathbf{X},\mathbf{B}) = 1] - \Pr[d(\mathbf{X},\mathbf{R}) = 1].
$$</p><p>Define the random variable $\mathbf{B}&rsquo;$ as follows:</p><p>$$
\mathbf{B}&rsquo; :=
\begin{cases}
\mathbf{R}, & \text{if } d(\mathbf{X},\mathbf{R}) = 1,\\
\overline{\mathbf{R}}, & \text{if } d(\mathbf{X},\mathbf{R}) = 0.
\end{cases}
$$</p><p>Then</p><p>$$
\Pr[\mathbf{B}&rsquo; = \mathbf{B}] = \frac{1}{2} + \varepsilon.
$$</p><p><em>Proof.</em> We compute $\Pr[\mathbf{B}&rsquo; = \mathbf{B}]$ by conditioning on the two cases $\mathbf{B} = \mathbf{R}$ and $\mathbf{B} \ne \mathbf{R}$:</p><p>$$
\begin{aligned}
\Pr[\mathbf{B}&rsquo; = \mathbf{B}] &= \Pr[\mathbf{B}&rsquo; = \mathbf{B} \mid \mathbf{B} = \mathbf{R}] \Pr[\mathbf{B}=\mathbf{R}] + \Pr[\mathbf{B}&rsquo; = \mathbf{B} \mid \mathbf{B} \ne \mathbf{R}] \Pr[\mathbf{B} \ne \mathbf{R}] \\
&= \Pr\bigl(d(\mathbf{X},\mathbf{R})=1 \big| \mathbf{B} = \mathbf{R}\bigr)\cdot\frac 12
\;+\; \Pr\bigl(d(\mathbf{X},\mathbf{R})=0 \big| \mathbf{B} \ne \mathbf{R}\bigr)\cdot\frac 12 \\
&= \frac 12\left(\Pr[d(\mathbf{X},\mathbf{R})=1 \mid \mathbf{B}=\mathbf{R}] + 1 - \Pr[d(\mathbf{X},\mathbf{R})=1 \mid \mathbf{B} \ne \mathbf{R}]\right) \\
&= \frac12 + \frac12(\alpha - \beta),
\end{aligned}
$$</p><p>where</p><p>$$
\alpha := \Pr[d(\mathbf{X},\mathbf{R})=1 \mid \mathbf{B} = \mathbf{R}], \qquad
\beta := \Pr[d(\mathbf{X},\mathbf{R})=1 \mid \mathbf{B} \ne \mathbf{R}].
$$</p><p>Due to independence, we have</p><p>$$
\alpha = \Pr[d(\mathbf{X},\mathbf{R})=1 \mid \mathbf{B} = \mathbf{R}] = \Pr[d(\mathbf{X},\mathbf{B})=1 \mid \mathbf{B}=\mathbf{R}] = \Pr[d(\mathbf{X},\mathbf{B})=1].
$$</p><p>From this:</p><p>$$
\begin{aligned}
\varepsilon &= \Pr[d(\mathbf{X},\mathbf{B})=1] - \Pr[d(\mathbf{X},\mathbf{R})=1] \\
&= \alpha - \left(
\Pr[d(\mathbf{X},\mathbf{R})=1 \mid \mathbf{B}=\mathbf{R}]\Pr[\mathbf{B}=\mathbf{R}] + \Pr[d(\mathbf{X},\mathbf{R})=1 \mid \mathbf{B}\ne \mathbf{R}]\Pr[\mathbf{B}\ne \mathbf{R}]
\right)\\
&= \alpha - \frac12(\alpha + \beta) = \frac12(\alpha - \beta),
\end{aligned}
$$</p><p>and substituting this into the formula above yields</p><p>$$
\Pr[\mathbf{B}&rsquo; = \mathbf{B}] = \frac12 + \varepsilon.
$$</p><hr><p><strong>Theorem 3.</strong> Let $G$ be a PRG defined on $(S,\left\lbrace 0,1\right\rbrace^L)$. If $G$ is <em>unpredictable</em>, then $G$ is <em>secure</em>. Specifically, for every adversary $\mathcal{A}$ that breaks the security of $G$ (in the PRG Attack Game), there exists an adversary $\mathcal{B}$ that breaks the unpredictability of $G$ (in the Unpredictable PRG Game), where $\mathcal{B}$ is a simple wrapper around $\mathcal{A}$, such that</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{A}, G] = L \cdot \mathtt{Pred}\text{adv}[\mathcal{B}, G].
$$</p><p><strong>Proof.</strong> Let $\mathcal{A}$ be an adversary against $G$ in the PRG Attack Game. Using $\mathcal{A}$, we construct a predictor $\mathcal{B}$ that attacks $G$ in the Unpredictable PRG Game as follows:</p><ul><li>Choose $\omega \in \left\lbrace 1,\ldots,L\right\rbrace$ uniformly at random.</li><li>Send $L - \omega$ to its challenger and receive a prefix string $x \in \left\lbrace 0,1\right\rbrace^{L-\omega}$.</li><li>Generate $\omega$ random bits $r_1,\ldots,r_\omega$, and send the $L$-bit string $x \Vert r_1\cdots r_\omega$ to $\mathcal{A}$.</li><li>If $\mathcal{A}$ outputs $1$, then output $r_1$; otherwise, output $\overline{r_1}$.</li></ul><p>To analyze $\mathcal{B}$, we consider $L+1$ hybrid games, called <strong>Hybrid 0</strong>, <strong>Hybrid 1</strong>, &mldr;, <strong>Hybrid $L$</strong>. For $j = 0,\ldots,L$, <strong>Hybrid $j$</strong> is defined as a game between $\mathcal{A}$ and a challenger who creates a bit string $r$ consisting of:</p><ul><li>$L - j$ pseudorandom bits, followed by</li><li>$j$ truly random bits.</li></ul><p>That is, the challenger chooses $s \in S$ and $t \in \left\lbrace 0,1\right\rbrace^j$ uniformly at random and sends $\mathcal{A}$ the string</p><p>$$
r := G(s)[0..L-j-1] \Vert t.
$$</p><p>As usual, $\mathcal{A}$ outputs $0$ or $1$ at the end of the game, and we denote by $p_j$ the probability that $\mathcal{A}$ outputs $1$ in <strong>Hybrid $j$</strong>.
Note that $p_0$ is the probability that $\mathcal{A}$ outputs $1$ in <strong>Experiment 0</strong> of the PRG Attack Game, while $p_L$ is the probability that $\mathcal{A}$ outputs $1$ in <strong>Experiment 1</strong>.</p><p>Let $W$ be the event that $\mathcal{B}$ wins the Unpredictable PRG Game (i.e., it correctly predicts the next bit). Then</p><p>$$
\begin{aligned}
\Pr[W]
&= \sum_{j=1}^{L} \Pr[W \mid \omega = j] \cdot \Pr[\omega = j] \\
&= \frac{1}{L} \sum_{j=1}^{L} \Pr[W \mid \omega = j] \\
&= \frac{1}{L} \sum_{j=1}^{L} \left( \frac12 + p_{j-1} - p_j \right)\quad\text{(by the Distinguisher/predictor lemma)} \\
&= \frac12 + \frac{1}{L}(p_0 - p_L),
\end{aligned}
$$</p><blockquote><p>To explain the transformation above, we analyze the predictor adversary $\mathcal{B}$ by considering the <strong>Hybrid $j$</strong> games.
By the definition above:</p><p>$$
r := G(s)[0..L-j-1] \Vert t,
$$</p><p>so we have:</p><table><thead><tr><th>Game</th><th>Bits $1 \ldots L-j-1$</th><th>Bits $L-j \ldots L$</th></tr></thead><tbody><tr><td>Hybrid $(j-1)$</td><td>Pseudorandom</td><td><strong>bit $x_{L-j}$ (pseudorandom), then $(j−1)$ random bits</strong></td></tr><tr><td>Hybrid $j$</td><td>Pseudorandom</td><td><strong>$j$ random bits</strong></td></tr></tbody></table><p>Thus, <strong>the two Hybrids differ exactly at bit position $L-j$</strong>:</p><ul><li>In Hybrid $(j-1)$: it&rsquo;s the <em>true</em> bit $x_{L-j}$ generated by the PRG.</li><li>In Hybrid $j$: it&rsquo;s a <em>random</em> bit $r$.</li></ul><p>In adversary $\mathcal{B}$&rsquo;s algorithm:</p><ul><li>The part $G(s)[0..L-j-1]$ serves as the <strong>side information</strong> $\mathbf{X}$ (known beforehand).</li><li>$\mathcal{B}$ shows $\mathcal{A}$ the prefix $\mathbf{X}$ concatenated with a <strong>bit</strong> $b$ at position $L-j$.</li><li>The bit $b$ is <strong>$x_{L-j}$</strong> (if simulating Hybrid $(j-1)$) or a <strong>random $r$</strong> (if simulating Hybrid $j$).</li><li>$\mathcal{A}$ outputs $d(\mathbf{X},b)\in \left\lbrace 0,1\right\rbrace$.</li><li>$\mathcal{B}$ then uses this output to <strong>predict</strong> the true bit $x_{L-j}$.</li></ul><table><thead><tr><th>Distinguisher/predictor Lemma</th><th>In our Proof</th></tr></thead><tbody><tr><td>$\mathbf{X}$</td><td>$G(s)[0..L-j-1]$</td></tr><tr><td>$\mathbf{B}$</td><td>The true bit $x_{L-j}$</td></tr><tr><td>$\mathbf{R}$</td><td>The random bit $r$</td></tr><tr><td>$d(\mathbf{X},\cdot)$</td><td>The output of $\mathcal{A}$</td></tr></tbody></table><p>The Distinguisher/predictor lemma states that if the predictor uses the rule:
If $d(\mathbf{X},\mathbf{R})=1$ → guess $\mathbf{B} = \mathbf{R}$,
If $d(\mathbf{X},\mathbf{R})=0$ → guess $\mathbf{B} = \overline{\mathbf{R}}$
then</p><p>$$
\Pr[W\mid \omega=j]
=\frac12 + \left(\Pr[d(\mathbf{X},\mathbf{B})=1] - \Pr[d(\mathbf{X},\mathbf{R})=1]\right).
$$</p><p>Where:</p><ul><li>$\Pr[d(\mathbf{X},\mathbf{B})=1] = p_{j-1}$ (the probability $\mathcal{A}$ outputs $1$ in Hybrid $(j-1)$),</li><li>$\Pr[d(\mathbf{X},\mathbf{R})=1] = p_j$ (the probability $\mathcal{A}$ outputs $1$ in Hybrid $j$).</li></ul><p>Therefore:</p><p>$$
\Pr[W\mid \omega=j] = \frac12 + (p_{j-1} - p_j).
$$</p></blockquote><p>and it follows that</p><p>$$
\mathtt{Pred}\text{adv}[\mathcal{B}, G] = \left|\Pr[W] - \frac12\right| = \frac{1}{L} \cdot |p_0 - p_L| = \frac{1}{L} \cdot \mathtt{PRG}\text{adv}[\mathcal{A}, G].
$$</p><p>This implies</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{A}, G] = L \cdot \mathtt{Pred}\text{adv}[\mathcal{B}, G],
$$</p><p>which proves the theorem. $\square$</p><hr><p>In this blog, we have taken a deep dive into two foundational aspects of pseudorandom generators. We have seen how the Blum-Micali sequential construction offers an elegant method to amplify the length of a pseudorandom sequence while preserving its security.</p><p>Most importantly, we have proven the tight equivalence between security (statistical indistinguishability) and unpredictability (the hardness of guessing the next bit). This result is not just theoretically beautiful but also has immense practical significance: it simplifies the task of proving PRGs secure. Instead of confronting an infinite number of potential statistical tests, we only need to prove that predicting the next bit is computationally infeasible.</p><p>With a secure PRG in hand, we now possess one of the most fundamental building blocks of modern cryptography. In future articles, we will see how these blocks are used to construct more complex cryptographic systems, such as stream ciphers.</p><h2 id=references>References</h2><ol><li>Dan Boneh and Victor Shoup. <em>A Graduate Course in Applied Cryptography</em>. Retrieved from <a href=https://toc.cryptobook.us/>https://toc.cryptobook.us/</a></li></ol><h2 id=connect-with-me>Connect with Me</h2><p>Connect with me on <a href=https://www.facebook.com/dangduongminhnhat/>Facebook</a>, <a href=https://www.linkedin.com/in/nhatdang1901/>LinkedIn</a>, via email at <a href=mailto:dangduongminhnhat2003@gmail.com>dangduongminhnhat2003@gmail.com</a>, <a href=https://github.com/dangduongminhnhat>GitHub</a>, or by phone at <a href=tel:+84829258815>+84 829 258 815</a>.</p><div class=blog-tags><a href=https://dangduongminhnhat.github.io/tags/cryptography/>Cryptography</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/pseudo-random-generator/>Pseudo-random Generator</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/blum-micali/>Blum-Micali</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/next-bit-test/>Next-Bit Test</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://dangduongminhnhat.github.io/posts/cryptography/p5/ data-toggle=tooltip data-placement=top title="Cryptography 5: Stream Cipher Vulnerabilities and the Hybrid Argument">&larr; Previous Post</a></li></ul><div id=utterances-comments><script src=https://utteranc.es/client.js repo=dangduongminhnhat/dangduongminhnhat.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"></ul><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2025
&nbsp;&bull;&nbsp;
<a href=https://dangduongminhnhat.github.io/>Daminha Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.129.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/load-photoswipe.js></script></body></html>