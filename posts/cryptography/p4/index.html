<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Cryptography 4: Constructing Secure Stream Ciphers from PRGs - Daminha Blog</title>
<meta name=description content="This post explores the stream cipher, a practical solution to the long-key problem of the One-Time Pad. We delve into how a &ldquo;pseudo-random generator&rdquo; (PRG) can &ldquo;stretch&rdquo; a short key (seed) into a long keystream for encryption. The article&rsquo;s core focuses on the formal security definition of a PRG—the concept of &ldquo;computational indistinguishability&rdquo;—and presents a detailed proof demonstrating that a secure PRG leads to a semantically secure stream cipher"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Daminha Blog","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p4\/","name":"Cryptography 4 constructing secure stream ciphers from prgs"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Dang Duong Minh Nhat"},"headline":"Cryptography 4: Constructing Secure Stream Ciphers from PRGs","description":"This post explores the stream cipher, a practical solution to the long-key problem of the One-Time Pad. We delve into how a \u0026ldquo;pseudo-random generator\u0026rdquo; (PRG) can \u0026ldquo;stretch\u0026rdquo; a short key (seed) into a long keystream for encryption. The article\u0026rsquo;s core focuses on the formal security definition of a PRG—the concept of \u0026ldquo;computational indistinguishability\u0026rdquo;—and presents a detailed proof demonstrating that a secure PRG leads to a semantically secure stream cipher","inLanguage":"en","wordCount":2490,"datePublished":"2025-08-13T12:50:54\u002b07:00","dateModified":"2025-08-13T12:50:54\u002b07:00","image":"https:\/\/dangduongminhnhat.github.io\/","keywords":["Cryptography, Stream Cipher, Pseudo-random Generator, Semantic Security, Security Reduction"],"mainEntityOfPage":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p4\/","publisher":{"@type":"Organization","name":"https:\/\/dangduongminhnhat.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/dangduongminhnhat.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Cryptography 4: Constructing Secure Stream Ciphers from PRGs"><meta property="og:description" content="This post explores the stream cipher, a practical solution to the long-key problem of the One-Time Pad. We delve into how a &ldquo;pseudo-random generator&rdquo; (PRG) can &ldquo;stretch&rdquo; a short key (seed) into a long keystream for encryption. The article&rsquo;s core focuses on the formal security definition of a PRG—the concept of &ldquo;computational indistinguishability&rdquo;—and presents a detailed proof demonstrating that a secure PRG leads to a semantically secure stream cipher"><meta property="og:url" content="https://dangduongminhnhat.github.io/posts/cryptography/p4/"><meta property="og:type" content="website"><meta property="og:site_name" content="Daminha Blog"><meta name=twitter:title content="Cryptography 4: Constructing Secure Stream Ciphers from PRGs"><meta name=twitter:description content="This post explores the stream cipher, a practical solution to the long-key problem of the One-Time Pad. We delve into how a &ldquo;pseudo-random generator&rdquo; (PRG) can &ldquo;stretch&rdquo; a …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.129.0"><link rel=alternate href=https://dangduongminhnhat.github.io/index.xml type=application/rss+xml title="Daminha Blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/syntax.css><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/theme-toggle.css><script>const savedTheme=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",savedTheme)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-V19WW5WSEZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-V19WW5WSEZ")}</script><link rel=apple-touch-icon sizes=180x180 href=/favicon_io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon_io/favicon-16x16.png><link rel=manifest href=/favicon_io/site.webmanifest><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      processEscapes: true
    }
  });
</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=google-site-verification content="ors8seNeA2TL4hvELynbBtrr4PwXapoPh2td6zTadCU"><meta name=google-site-verification content="oQJmyNtEP9HjjEcXwRno2_YPeuLd5kX3jTltynIx65s"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://dangduongminhnhat.github.io/>Daminha Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=About href=/posts/about-me/>About</a></li><li><a title=Tags href=/tags/>Tags</a></li><li><a title="Cryptography Series" href=/posts/cryptography/>Cryptography Series</a></li><li><a title=Note href=https://hackmd.io/@daminha>Note</a></li><li><a title=Blog href=/posts/blog/>Blog</a></li><li><a href=javascript:void(0); onclick=toggleTheme() style=outline:none><span class="hidden-sm hidden-md hidden-lg">Theme</span>
<span class="glyphicon glyphicon-adjust" id=themeGlyph></span></a></li></ul></div></div></nav><script>document.addEventListener("DOMContentLoaded",function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e),window.toggleTheme=function(){const t=document.documentElement.getAttribute("data-theme"),e=t==="dark"?"light":"dark";document.documentElement.setAttribute("data-theme",e),localStorage.setItem("theme",e)}})</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=posts-heading><h1>Cryptography 4: Constructing Secure Stream Ciphers from PRGs</h1><hr class=small></div></div></div></div></div><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p><strong>Posted on:</strong> August 13, 2025 |
<strong>Reading time:</strong> 12 minutes |
<strong>Word count:</strong> 2490 words |
<strong>Author:</strong> Dang Duong Minh Nhat</p><p>In previous posts, I introduced the concepts of <strong>perfectly secure encryption</strong> and <strong>semantically secure encryption</strong>. The problem with perfect security is that achieving it requires the use of very long keys. The notion of semantic security was introduced as a weaker concept that might allow us to build secure schemes using only relatively short keys; however, we have not yet constructed such a scheme. We will now study a type of scheme that can do just that: the <strong>stream cipher</strong>.</p><p>I recommend you read <a href=https://dangduongminhnhat.github.io/posts/cryptography/p3/>Part 3</a> and other blogs in the <a href=https://dangduongminhnhat.github.io/posts/cryptography/>series</a> first to understand the theories for this post. Okay, let&rsquo;s get started.</p><hr><h3 id=pseudo-random-generators>Pseudo-random Generators</h3><p>Recall the <strong>One-Time Pad</strong>: Here, the key, plaintext, and ciphertext are all $L$-bit strings. However, we want to use a much shorter key. The idea is to use an $\ell$-bit <strong>seed</strong> $s$ (where $\ell$ is much smaller than $L$) as the encryption key, and then “stretch” this seed into a long $L$-bit string to use as a mask for the plaintext (and to unmask it during decryption).</p><p>This string $s$ is stretched by an efficient, deterministic algorithm $G$ that maps $\ell$-bit strings to $L$-bit strings. Thus, the <strong>key space</strong> for this modified version of the One-Time Pad is $\left\lbrace 0,1\right\rbrace^\ell$, while the plaintext and ciphertext spaces are $\left\lbrace 0,1\right\rbrace^L$.</p><p>For $s \in \left\lbrace 0,1\right\rbrace^\ell$ and $m, c \in \left\lbrace 0,1\right\rbrace^L$, we define:</p><p>$E(s, m) := G(s) \oplus m \quad \text{and} \quad D(s, c) := G(s) \oplus c.$</p><p>This modified version of the One-Time Pad is called a <strong>stream cipher</strong>, and the function $G$ is called a <strong>pseudo-random generator (PRG)</strong>.</p><p>If $\ell &lt; L$, then by <strong>Shannon&rsquo;s Theorem</strong>, this stream cipher cannot achieve perfect security; however, if $G$ satisfies an appropriate security property, this scheme can achieve semantic security.</p><p>Suppose $s$ is a random $\ell$-bit string and $r$ is a random $L$-bit string. Intuitively, if an attacker <strong>cannot efficiently distinguish</strong> $G(s)$ from $r$, then they should also be unable to distinguish this stream cipher from the One-Time Pad; furthermore, since the One-Time Pad is semantically secure, this stream cipher should be as well. To make this argument rigorous, we need to <strong>formalize the notion</strong> that “an attacker cannot efficiently distinguish $G(s)$ from $r$.”</p><hr><p>An <strong>algorithm</strong> used to distinguish a pseudo-random string $G(s)$ from a truly random string $r$ is called a <strong>statistical test</strong>. It takes a string as input and outputs either $0$ or $1$.</p><p>The test is called <strong>effective</strong> if the probability that it outputs $1$ on a pseudo-random input is <strong>significantly different</strong> from the probability that it outputs $1$ on a truly random input.</p><p>Even a difference of about $1%$ is considered significant; indeed, with just a $1%$ difference, if we obtain a few hundred independent samples (all pseudo-random or all truly random), we can infer with high confidence which type of string we are dealing with. However, if the difference is non-zero but <strong>negligible</strong>, such as $2^{-100}$, it is not useful.</p><hr><p><strong>How to design an effective statistical test:</strong></p><p>A basic approach is: given an $L$-bit string, compute some <strong>statistic</strong>, and then check if this statistic differs significantly from its expected value if the string were truly random.</p><p><strong>Example:</strong> A simple and easy-to-compute statistic is the number of $1$s in the string, let&rsquo;s call it $k$.</p><ul><li>For a truly random string, we expect $k \approx L/2$.</li><li>If the PRG $G$ has a bias towards the bit $0$ or $1$, we can detect this with a statistical test that, for instance:</li></ul><p>$$\text{outputs } 1 \ \text{if} \ |k - 0.5L| &lt; 0.01L, \ \text{otherwise outputs } 0.$$</p><p>This test would be quite effective if $G$ indeed has a significant bias.</p><hr><p>The above test can be <strong>enhanced</strong> by considering not just individual bits but also <strong>pairs of bits</strong>.</p><ul><li>Divide the $L$-bit string into approximately $L/2$ pairs of bits.</li><li>Count the number $k_{00}$ of <code>00</code> pairs, the number $k_{01}$ of <code>01</code> pairs, the number $k_{10}$ of <code>10</code> pairs, and the number $k_{11}$ of <code>11</code> pairs.</li><li>For a truly random string, each expected value would be around:</li></ul><p>$$L/2 \cdot \frac14 = L/8.$$</p><p>A natural test would be to check if the <strong>distance</strong> between each of these values and $L/8$ is smaller than a certain threshold.</p><p>Or we could <strong>sum the squares of these distances</strong> and check if that sum is less than a given threshold – this is the classic <strong>$\chi^2$ (chi-squared) test</strong> in statistics.</p><p>Clearly, this idea can be extended from pairs of bits to any $n$-bit block.</p><hr><p>There are many other simple statistics that can be checked. However, such simple tests often <strong>do not exploit</strong> the deeper mathematical properties of the algorithm $G$ that a sophisticated attacker might leverage to design a <strong>specialized</strong> statistical test against $G$.</p><p>For example: There are PRGs for which the simple tests in the previous two paragraphs are <strong>completely ineffective</strong>, yet they are entirely <strong>predictable</strong> if enough output bits are known; that is, given a sufficiently long prefix of $G(s)$, an attacker can compute <strong>all the remaining bits</strong> of $G(s)$, or even compute the <strong>seed</strong> $s$.</p><p>Thus, the <strong>security definition</strong> of a PRG will be <strong>formalized</strong> with the idea that <strong>no</strong> efficient (and efficiently computable) statistical test exists.</p><hr><h3 id=definition-of-a-pseudo-random-generator>Definition of a Pseudo-random Generator</h3><p>A <strong>pseudo-random generator (PRG)</strong> is an <strong>efficient</strong>, <strong>deterministic</strong> algorithm $G$ that, when given a <strong>seed</strong> $s$ as input, computes an output $r$.</p><p>The seed $s$ belongs to a <strong>finite seed space</strong> $\mathcal{S}$, and the output $r$ belongs to a <strong>finite output space</strong> $\mathcal{R}$. Typically, $\mathcal{S}$ and $\mathcal{R}$ are sets of bit strings of a fixed length (for example, in the discussion above, we had $\mathcal{S} = \left\lbrace 0,1\right\rbrace^\ell$ and $\mathcal{R} = \left\lbrace 0,1\right\rbrace^L$). We say that $G$ is a PRG defined on $(\mathcal{S}, \mathcal{R})$.</p><p>The definition of <strong>security</strong> for a PRG aims to capture the intuition that if $s$ is chosen randomly from $\mathcal{S}$ and $r$ is chosen randomly from $\mathcal{R}$, then <strong>no efficient adversary</strong> can reliably distinguish between $G(s)$ and $r$: these two cases are <strong>computationally indistinguishable</strong>.</p><p>This definition is described in terms of an <strong>attack game</strong>.</p><hr><p><strong>The PRG Attack Game.</strong> For a PRG $G$ defined on $(\mathcal{S}, \mathcal{R})$ and an adversary $\mathcal{A}$, we define <strong>two experiments</strong>: <strong>Experiment 0</strong> and <strong>Experiment 1</strong>. For $b \in \left\lbrace 0, 1\right\rbrace$, we define:</p><p><strong>Experiment b:</strong> The challenger computes $r \in \mathcal{R}$ and sends $r$ to the adversary.</p><ul><li><strong>If $b = 0$</strong>: $s \xleftarrow{R} \mathcal{S}$, $r \leftarrow G(s)$</li><li><strong>If $b = 1$</strong>: $r \xleftarrow{R} \mathcal{R}$</li></ul><p><strong>The Adversary</strong>: Upon receiving $r$, the adversary computes and outputs a bit $\hat{b} \in \left\lbrace 0, 1\right\rbrace$.</p><hr><p>Let $W_b$ be the event that &ldquo;the adversary $\mathcal{A}$ outputs $1$ in <strong>Experiment b</strong>&rdquo;.</p><p>We define the <strong>advantage</strong> of $\mathcal{A}$ against $G$ as follows:</p><p>$$\mathtt{PRG}\text{adv}[\mathcal{A}, G] := \left| \Pr[W_0] - \Pr[W_1] \right|.$$</p><hr><p><strong>Definition (Secure PRG).</strong> A PRG $G$ is called <strong>secure</strong> if the value $\mathtt{PRG}\text{adv}[\mathcal{A}, G]$ is <strong>negligible</strong> for <strong>every</strong> efficient adversary $\mathcal{A}$.</p><hr><p>As mentioned in the post <a href=https://dangduongminhnhat.github.io/posts/cryptography/p3/>Cryptography 3</a>, the <strong>PRG Attack Game</strong> can be rewritten as a &ldquo;bit-guessing&rdquo; game, where instead of running two separate experiments, the <strong>challenger</strong> randomly chooses $b \in \left\lbrace 0, 1\right\rbrace$ and then runs <strong>Experiment b</strong> with the adversary $\mathcal{A}$.</p><p>In this game, we measure the <strong>bit-guessing advantage</strong> of $\mathcal{A}$:</p><p>$$\mathtt{PRG}\text{adv}^\ast[\mathcal{A}, G] := \left| \Pr[\hat{b} = b] - \frac12 \right|.$$</p><p>The general result applied here is:</p><p>$$\mathtt{PRG}\text{adv}[\mathcal{A}, G] = 2 \cdot \mathtt{PRG}\text{adv}^\ast[\mathcal{A}, G]. \tag{1}$$</p><hr><h3 id=stream-ciphers-encryption-with-a-prg>Stream Ciphers: Encryption with a PRG</h3><p>Let $G$ be a PRG defined on $(\left\lbrace 0, 1\right\rbrace^\ell, \left\lbrace 0, 1\right\rbrace^L)$; that is, $G$ expands an $\ell$-bit seed into an $L$-bit output. The stream cipher $\mathcal{E} = (E, D)$ constructed from $G$ is defined on $(\left\lbrace 0, 1\right\rbrace^\ell, \left\lbrace 0, 1\right\rbrace^{\le L}, \left\lbrace 0, 1\right\rbrace^{\le L})$; for $s \in \left\lbrace 0, 1\right\rbrace^\ell$ and $m, c \in \left\lbrace 0, 1\right\rbrace^{\le L}$, the encryption and decryption operations are defined as follows: if $|m| = v$, then</p><p>$$E(s, m) := G(s)[0 \dots v - 1] \oplus m,$$</p><p>and if $|c| = v$, then</p><p>$$D(s, c) := G(s)[0 \dots v - 1] \oplus c.$$</p><p>As the reader can easily verify, this satisfies the definition of an encryption scheme (in particular, the correctness property).</p><p>Note that, for analyzing the semantic security of $\mathcal{E}$, the length associated with a message $m$ in the Semantic Security Attack Game is its natural length $|m|$ in bits. Also, note that if $v$ is much smaller than $L$, then for many practical PRGs, it is possible to compute the first $v$ bits of $G(s)$ much more quickly than computing all $L$ bits of $G(s)$ and then truncating.</p><p>The main result of this section is:</p><hr><p><strong>Theorem 1.</strong> If $G$ is a secure PRG, then the stream cipher $\mathcal{E}$ constructed from $G$ is a semantically secure encryption scheme.</p><p>Specifically, for any $\mathtt{SS}$ adversary $\mathcal{A}$ targeting $\mathcal{E}$ as in the Semantic Security Attack Game, there exists a PRG adversary $\mathcal{B}$ targeting $G$ as in the PRG Attack Game, where $\mathcal{B}$ is just a simple wrapper around $\mathcal{A}$, such that</p><p>$$\mathtt{SS}\texttt{adv}[\mathcal{A}, \mathcal{E}] = 2 \cdot \mathtt{PRG}\texttt{adv}[\mathcal{B}, G]. \tag{2}$$</p><p><strong>Proof.</strong> Suppose $\mathcal{A}$ is an efficient adversary targeting $\mathcal{E}$ in the Semantic Security Attack Game. We want to show that $\mathtt{SS}\texttt{adv}[\mathcal{A}, \mathcal{E}]$ is negligible, assuming $G$ is a secure PRG. Instead of proving (2) directly, we will work with the bit-guessing version of the SS attack game by proving:</p><p>$$\mathtt{SS}\texttt{adv}^*[\mathcal{A}, \mathcal{E}] = \mathtt{PRG}\texttt{adv}[\mathcal{B}, G] \tag{3}$$</p><p>for an efficient adversary $\mathcal{B}$. Then (2) will follow from Theorem 3 in the <a href=https://dangduongminhnhat.github.io/posts/cryptography/p3/>Cryptography 3</a> post. Furthermore, under the assumption that $G$ is a secure PRG, the value $\mathtt{PRG}\texttt{adv}[\mathcal{B}, G]$ will be negligible, and therefore $\mathtt{SS}\texttt{adv}[\mathcal{A}, \mathcal{E}]$ will also be negligible (which is what we need to prove).</p><hr><p>Next, consider $\mathcal{A}$&rsquo;s attack on $\mathcal{E}$ in the bit-guessing version of the Semantic Security Attack Game. In this game, $\mathcal{A}$ gives the challenger two messages $m_0, m_1$ of the same length; the challenger randomly chooses a key $s$ and a bit $b$, and encrypts $m_b$ under key $s$, giving the ciphertext $c$ to $\mathcal{A}$; finally, $\mathcal{A}$ outputs a bit $\hat{b}$. The adversary $A$ wins if $\hat{b} = b$.</p><hr><p>Let&rsquo;s call this game <strong>Game 0</strong>. The challenger&rsquo;s logic in this game can be written as follows:</p><p>Receive $m_0, m_1 \in \left\lbrace 0, 1\right\rbrace^v$ from $\mathcal{A}$, with $v \le L$, then:</p><ul><li>$b \xleftarrow{R} \left\lbrace 0, 1\right\rbrace$</li><li>$s \xleftarrow{R} \left\lbrace 0, 1\right\rbrace^\ell$, $r \leftarrow G(s)$</li><li>$c \leftarrow r[0 \dots v-1] \oplus m_b$</li><li>send $c$ to $\mathcal{A}$.</li></ul><p>Let $W_0$ be the event $\hat{b} = b$ in Game 0. By definition:</p><p>$$\mathtt{SS}\texttt{adv}^*[\mathcal{A}, \mathcal{E}] = | \Pr[W_0] - 1/2 |. \tag{4}$$</p><hr><p>Next, we modify the challenger of Game 0 to create <strong>Game 1</strong>, which is identical to Game 0 except that the challenger uses a truly random string instead of a pseudo-random one. The logic of Game 1 is as follows:</p><p>Receive $m_0, m_1 \in \left\lbrace 0, 1\right\rbrace^v$ from $\mathcal{A}$, with $v \le L$, then:</p><ul><li>$b \xleftarrow{R} \left\lbrace 0, 1\right\rbrace$</li><li>$r \xleftarrow{R} \left\lbrace 0, 1\right\rbrace^L$</li><li>$c \leftarrow r[0 \dots v-1] \oplus m_b$</li><li>send $c$ to $\mathcal{A}$.</li></ul><hr><p>Let $W_1$ be the event $\hat{b} = b$ in Game 1. We have:</p><p>$$\Pr[W_1] = 1/2. \tag{5}$$</p><p>This is because in Game 1, the adversary is attacking a <strong>variable-length one-time pad</strong>. The output $\hat{b}$ of $\mathcal{A}$ and the challenger&rsquo;s secret bit $b$ are independent.</p><hr><p>Finally, we need to construct a PRG adversary $\mathcal{B}$ that uses $\mathcal{A}$ as a subroutine, such that:</p><p>$$|\Pr[W_0] - \Pr[W_1]| = \mathtt{PRG}\texttt{adv}[\mathcal{B}, G]. \tag{6}$$</p><hr><p>$\mathcal{B}$ receives $r \in \left\lbrace 0, 1\right\rbrace^L$ from its PRG challenger and plays the role of the challenger for $\mathcal{A}$:</p><p>Receive $m_0, m_1 \in \left\lbrace 0, 1\right\rbrace^v$ from $\mathcal{A}$, with $v \le L$, then:</p><ul><li>$b \xleftarrow{R} \left\lbrace 0, 1\right\rbrace$</li><li>$c \leftarrow r[0 \dots v-1] \oplus m_b$</li><li>send $c$ to $\mathcal{A}$.</li></ul><p>When $\mathcal{A}$ outputs $\hat{b}$, $\mathcal{B}$ outputs $\delta(\hat{b}, b)$, where:</p><p>$$
\delta(x, y) :=
\begin{cases}
1 & \text{if } x = y, \\
0 & \text{if } x \ne y.
\end{cases} \tag{7}
$$</p><p>Let $p_0$ be the probability that $\mathcal{B}$ outputs $1$ when the <strong>PRG challenger</strong> is running <em>Experiment 0</em> of the <strong>PRG Attack Game</strong>, and let $p_1$ be the probability that $\mathcal{B}$ outputs $1$ when the <strong>PRG challenger</strong> is running <em>Experiment 1</em> of the <strong>PRG Attack Game</strong>. By definition,</p><p>$$\mathtt{PRG}\texttt{adv}[\mathcal{B}, G] = |p_1 - p_0|.$$</p><p>Furthermore, if the <strong>PRG challenger</strong> is running <em>Experiment 0</em>, then the adversary $\mathcal{A}$ is essentially playing our <strong>Game 0</strong>, and thus $p_0 = \Pr[W_0]$. Similarly, if the <strong>PRG challenger</strong> is running <em>Experiment 1</em>, then $A$ is essentially playing our <strong>Game 1</strong>, and thus $p_1 = \Pr[W_1]$. Therefore, we can immediately obtain equation $(6)$.</p><p>Combining $(4), (5)$, and $(6)$ yields $(3)$. ✷</p><p>In the theorem above, we have <strong>reduced</strong> the security of $\mathcal{E}$ to the security of $G$ by showing that: if there exists an efficient $\mathtt{SS}$ adversary $\mathcal{A}$ that attacks $\mathcal{E}$, then there exists an efficient PRG adversary $\mathcal{B}$ that attacks $G$ satisfying:</p><p>$$\mathtt{SS}\texttt{adv}[\mathcal{A}, \mathcal{E}] \le 2 \cdot \mathtt{PRG}\texttt{adv}[\mathcal{B}, G]$$</p><p>We have shown that if $G$ is secure, then $\mathtt{PRG}\texttt{adv}[\mathcal{B}, G]$ is <strong>negligible</strong>, so by the inequality above, we conclude that $\mathtt{SS}\texttt{adv}[\mathcal{A}, \mathcal{E}]$ is also <strong>negligible</strong>. Since this holds for <strong>every</strong> efficient adversary $\mathcal{A}$, we conclude that $\mathcal{E}$ is <strong>semantically secure</strong>.</p><p>Another way to frame the proof is using the <strong>contrapositive</strong>. Indeed, if we assume $\mathcal{E}$ is <strong>not secure</strong>, then there would exist an efficient adversary $\mathcal{A}$ such that $\mathtt{SS}\texttt{adv}[\mathcal{A}, \mathcal{E}]$ is <strong>non-negligible</strong>, and the reduction (along with the inequality above) gives us an efficient adversary $\mathcal{B}$ such that $\mathtt{PRG}\texttt{adv}[\mathcal{B}, G]$ is also non-negligible. In other words, if we can break $\mathcal{E}$, we can also break $G$. Although logically equivalent, this style of proof has a different &ldquo;feel&rdquo; in that we start with an adversary $\mathcal{A}$ that breaks $\mathcal{E}$, and show how to use $\mathcal{A}$ to build a new adversary $\mathcal{B}$ that breaks $G$.</p><p>We also note that the proof of the theorem above follows the same <strong>basic logical pattern</strong> as the analysis of the “Internet roulette” game in <a href=https://dangduongminhnhat.github.io/posts/cryptography/p3/>Cryptography 3</a>. This is a <strong>proof template</strong> that will be repeated and extended many times throughout this book. The reader is encouraged to study both of these analyses to ensure they truly understand the process.</p><hr><p>In this post, we have journeyed from a theoretical problem—how to achieve secure encryption with a short key—to a concrete and elegant solution: the stream cipher. By replacing the truly random keystream of the One-Time Pad with the output of a Pseudo-random Generator (PRG), we have successfully constructed a semantically secure scheme.</p><p>The linchpin of this entire construction is the formal definition and assurance that the PRG&rsquo;s output is computationally indistinguishable from a truly random string. The proof technique of &ldquo;reducing&rdquo; the stream cipher&rsquo;s security to the PRG&rsquo;s security is not just a theoretical exercise; it is one of the most fundamental and powerful thinking patterns in modern cryptography. Understanding this method opens the door to analyzing many more complex protocols and schemes that we will explore later.</p><h2 id=references>References</h2><ol><li>Dan Boneh and Victor Shoup. <em>A Graduate Course in Applied Cryptography</em>. Retrieved from <a href=https://toc.cryptobook.us/>https://toc.cryptobook.us/</a></li></ol><h2 id=connect-with-me>Connect with Me</h2><p>Connect with me on <a href=https://www.facebook.com/dangduongminhnhat/>Facebook</a>, <a href=https://www.linkedin.com/in/nhatdang1901/>LinkedIn</a>, via email at <a href=mailto:dangduongminhnhat2003@gmail.com>dangduongminhnhat2003@gmail.com</a>, <a href=https://github.com/dangduongminhnhat>GitHub</a>, or by phone at <a href=tel:+84829258815>+84 829 258 815</a>.</p><div class=blog-tags><a href=https://dangduongminhnhat.github.io/tags/cryptography/>Cryptography</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/stream-cipher/>Stream Cipher</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/pseudo-random-generator/>Pseudo-random Generator</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/semantic-security/>Semantic Security</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/security-reduction/>Security Reduction</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://dangduongminhnhat.github.io/posts/cryptography/p3/ data-toggle=tooltip data-placement=top title="Cryptography 3: Consequences and Interpretations of Semantic Security">&larr; Previous Post</a></li></ul><div id=utterances-comments><script src=https://utteranc.es/client.js repo=dangduongminhnhat/dangduongminhnhat.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"></ul><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2025
&nbsp;&bull;&nbsp;
<a href=https://dangduongminhnhat.github.io/>Daminha Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.129.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/load-photoswipe.js></script></body></html>