<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Cryptography 5: Stream Cipher Vulnerabilities and the Hybrid Argument - Daminha Blog</title>
<meta name=description content="This blog delves into two critical aspects of stream ciphers and pseudorandom generators (PRGs). The first part exposes severe vulnerabilities that arise from the misuse of stream ciphers, focusing on two classic attacks: the &ldquo;two-time pad&rdquo; flaw, where key reuse leads to complete plaintext disclosure, and &ldquo;malleability,&rdquo; which allows an attacker to modify message content undetectably. The second part shifts from attacks to constructions, introducing a method for combining secure PRGs to create a new one with a longer output. The centerpiece of this section is the detailed presentation of the &ldquo;hybrid argument,&rdquo; a fundamental and powerful proof technique widely used in modern cryptography to demonstrate the security of protocols."><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Daminha Blog","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p5\/","name":"Cryptography 5 stream cipher vulnerabilities and the hybrid argument"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Dang Duong Minh Nhat"},"headline":"Cryptography 5: Stream Cipher Vulnerabilities and the Hybrid Argument","description":"This blog delves into two critical aspects of stream ciphers and pseudorandom generators (PRGs). The first part exposes severe vulnerabilities that arise from the misuse of stream ciphers, focusing on two classic attacks: the \u0026ldquo;two-time pad\u0026rdquo; flaw, where key reuse leads to complete plaintext disclosure, and \u0026ldquo;malleability,\u0026rdquo; which allows an attacker to modify message content undetectably. The second part shifts from attacks to constructions, introducing a method for combining secure PRGs to create a new one with a longer output. The centerpiece of this section is the detailed presentation of the \u0026ldquo;hybrid argument,\u0026rdquo; a fundamental and powerful proof technique widely used in modern cryptography to demonstrate the security of protocols.","inLanguage":"en","wordCount":2507,"datePublished":"2025-08-14T15:20:00\u002b07:00","dateModified":"2025-08-14T15:20:00\u002b07:00","image":"https:\/\/dangduongminhnhat.github.io\/","keywords":["Cryptography, Stream Cipher, CyberSecurity"],"mainEntityOfPage":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p5\/","publisher":{"@type":"Organization","name":"https:\/\/dangduongminhnhat.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/dangduongminhnhat.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Cryptography 5: Stream Cipher Vulnerabilities and the Hybrid Argument"><meta property="og:description" content="This blog delves into two critical aspects of stream ciphers and pseudorandom generators (PRGs). The first part exposes severe vulnerabilities that arise from the misuse of stream ciphers, focusing on two classic attacks: the &ldquo;two-time pad&rdquo; flaw, where key reuse leads to complete plaintext disclosure, and &ldquo;malleability,&rdquo; which allows an attacker to modify message content undetectably. The second part shifts from attacks to constructions, introducing a method for combining secure PRGs to create a new one with a longer output. The centerpiece of this section is the detailed presentation of the &ldquo;hybrid argument,&rdquo; a fundamental and powerful proof technique widely used in modern cryptography to demonstrate the security of protocols."><meta property="og:url" content="https://dangduongminhnhat.github.io/posts/cryptography/p5/"><meta property="og:type" content="website"><meta property="og:site_name" content="Daminha Blog"><meta name=twitter:title content="Cryptography 5: Stream Cipher Vulnerabilities and the Hybrid Argument"><meta name=twitter:description content="This blog delves into two critical aspects of stream ciphers and pseudorandom generators (PRGs). The first part exposes severe vulnerabilities that arise from the misuse of stream ciphers, focusing on …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.129.0"><link rel=alternate href=https://dangduongminhnhat.github.io/index.xml type=application/rss+xml title="Daminha Blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/syntax.css><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/theme-toggle.css><script>const savedTheme=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",savedTheme)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-V19WW5WSEZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-V19WW5WSEZ")}</script><link rel=apple-touch-icon sizes=180x180 href=/favicon_io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon_io/favicon-16x16.png><link rel=manifest href=/favicon_io/site.webmanifest><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      processEscapes: true
    }
  });
</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=google-site-verification content="ors8seNeA2TL4hvELynbBtrr4PwXapoPh2td6zTadCU"><meta name=google-site-verification content="oQJmyNtEP9HjjEcXwRno2_YPeuLd5kX3jTltynIx65s"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://dangduongminhnhat.github.io/>Daminha Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=About href=/posts/about-me/>About</a></li><li><a title=Tags href=/tags/>Tags</a></li><li><a title="Cryptography Series" href=/posts/cryptography/>Cryptography Series</a></li><li><a title=Note href=https://hackmd.io/@daminha>Note</a></li><li><a title=Blog href=/posts/blog/>Blog</a></li><li><a href=javascript:void(0); onclick=toggleTheme() style=outline:none><span class="hidden-sm hidden-md hidden-lg">Theme</span>
<span class="glyphicon glyphicon-adjust" id=themeGlyph></span></a></li></ul></div></div></nav><script>document.addEventListener("DOMContentLoaded",function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e),window.toggleTheme=function(){const t=document.documentElement.getAttribute("data-theme"),e=t==="dark"?"light":"dark";document.documentElement.setAttribute("data-theme",e),localStorage.setItem("theme",e)}})</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=posts-heading><h1>Cryptography 5: Stream Cipher Vulnerabilities and the Hybrid Argument</h1><hr class=small></div></div></div></div></div><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p><strong>Posted on:</strong> August 14, 2025 |
<strong>Reading time:</strong> 12 minutes |
<strong>Word count:</strong> 2507 words |
<strong>Author:</strong> Dang Duong Minh Nhat</p><p>Hello everyone, today we’ll continue with episode 5 in this series. The topic will be exploring the limitations of stream ciphers, and at the same time, introducing the hybrid argument. I recommend reading the previous posts in this <a href=https://dangduongminhnhat.github.io/posts/cryptography/>series</a> first.
Alright, let’s get started.</p><hr><h2 id=limitations-of-stream-ciphers-attacks-on-the-one-time-pad>Limitations of Stream Ciphers: Attacks on the One-Time Pad</h2><p>Although stream ciphers achieve semantic security, they are quite fragile and become insecure if misused.</p><h3 id=the-two-time-pad-is-insecure>The Two-Time Pad is Insecure</h3><p>A well-designed stream cipher can securely encrypt a single message from Alice to Bob. However, Alice may want to send multiple messages to Bob. Suppose, for simplicity, Alice wants to encrypt two messages, $m_1$ and $m_2$.</p><p>The naive approach is to encrypt both messages with the same stream cipher key $s$:</p><p>$$
c_1 \leftarrow m_1 \oplus G(s) \quad \text{and} \quad c_2 \leftarrow m_2 \oplus G(s) \tag{1}
$$</p><p>A moment&rsquo;s thought reveals that this construction is <strong>very</strong> insecure. An attacker who intercepts $c_1$ and $c_2$ can compute:</p><p>$$
\Delta := c_1 \oplus c_2 = (m_1 \oplus G(s)) \oplus (m_2 \oplus G(s)) = m_1 \oplus m_2
$$</p><p>From this, they obtain the XOR of $m_1$ and $m_2$. Unsurprisingly, English text contains enough redundancy that, given $\Delta = m_1 \oplus m_2$, an attacker can recover both $m_1$ and $m_2$ in the clear (plaintext). Therefore, construction $(1)$ leaks the plaintext after observing just two sufficiently long ciphertexts.</p><p>Construction $(1)$ is often jokingly called the <strong>two-time pad</strong>. As we have just analyzed, the two-time pad is completely insecure. In particular, <strong>a stream cipher key must never be used to encrypt more than one message</strong>. In situations where a key must be used multiple times, stream ciphers should never be used directly.</p><p>The incorrect reuse of a stream cipher key is a common mistake in real-world systems. For example, a protocol called <strong>PPTP</strong> allows two parties, $A$ and $B$, to send encrypted messages to each other. In Windows NT, Microsoft implemented PPTP using a stream cipher called <strong>RC4</strong>. The initial version encrypted messages from $A$ to $B$ with the <strong>same RC4 key</strong> as messages from $B$ to $A$. Consequently, by simply eavesdropping on two encrypted messages traveling in opposite directions, an attacker could recover the plaintext of both messages.</p><p>Another interesting story about the two-time pad is told by <strong>Klehr</strong>, who details how Russian spies in the US during World War II sent messages to Moscow using one-time pads. The system had a critical flaw, as Klehr explains:</p><blockquote><p>During World War II, the Soviet Union could not produce a sufficient quantity of one-time pads to meet the huge demand. So, they used some one-time pads <strong>twice</strong>, thinking this would not endanger the system. US counter-intelligence during WWII collected all international telegrams sent and received. Starting in 1946, in cooperation with the British, they launched an effort to decrypt Soviet messages and, thanks to the error of reusing one-time pads as two-time pads, they were able, over the next 25 years, to decrypt about 2,900 messages (equivalent to 5,000 pages) out of the hundreds of thousands of messages sent between 1941 and 1946 (when the Soviets switched to a different system).</p></blockquote><p>This decryption effort was codenamed <strong>Project Venona</strong>. The Venona documents are most famous for exposing <strong>Julius and Ethel Rosenberg</strong>, providing evidence of their involvement with the Soviet spy network. Starting in 1995, all 3,000 decrypted Venona messages were declassified.</p><hr><h3 id=the-one-time-pad-is-malleable>The One-Time Pad is Malleable</h3><p>Although semantic security ensures that an attacker cannot read the plaintext, it provides <strong>no</strong> guarantee of integrity. When using a stream cipher, an attacker can modify a ciphertext, and this modification <strong>will never</strong> be detected by the decryption algorithm. Even worse, we will see that by modifying the ciphertext, an attacker can <strong>control</strong> how the decrypted plaintext is changed.</p><p>Suppose an attacker intercepts the ciphertext:</p><p>$$
c := E(s, m) = m \oplus G(s)
$$</p><p>The attacker modifies $c$ to:</p><p>$$
c&rsquo; := c \oplus \Delta
$$</p><p>where $\Delta$ is chosen arbitrarily by the attacker. When the decryption algorithm receives the modified message, it will output:</p><p>$$
D(s, c&rsquo;) = c&rsquo; \oplus G(s) = (c \oplus \Delta) \oplus G(s) = m \oplus \Delta
$$</p><p>Thus, <strong>even without knowing</strong> $m$ or $s$, the attacker can cause the decrypted plaintext to become $m \oplus \Delta$ for a $\Delta$ of their choosing. We say that <strong>stream ciphers are malleable</strong>, because an attacker can create predictable changes to the plaintext.</p><hr><p><strong>Illustrative Example</strong></p><p>A simple example where malleability can help an attacker is in an encrypted file system.</p><p>Suppose specifically that <strong>Bob</strong> is a professor and <strong>Alice</strong> and <strong>Molly</strong> are students. Bob&rsquo;s students submit their homework assignments via email, and Bob saves these emails to a drive encrypted with a stream cipher. An email always starts with a standard header. To simplify, let&rsquo;s assume an email from Alice <strong>always</strong> starts with the string <code>"From:Alice"</code>.</p><p>Now, suppose Molly can access Bob&rsquo;s drive and find the ciphertext of Alice&rsquo;s homework email. Molly can claim credit for Alice&rsquo;s work as follows:</p><ul><li>She simply <strong>XORs</strong> the appropriate 5-character string into the ciphertext at positions 6 through 10 to change the header <code>"From:Alice"</code> to <code>"From:Molly"</code>.</li><li>Molly performs this change <strong>only on the ciphertext</strong> and <strong>does not need to know</strong> Bob&rsquo;s secret key.</li><li>Bob will never know that the header has been changed. When grading, Bob will think the assignment is from Molly, and Molly will get the grade instead of Alice.</li></ul><p>Of course, for this attack to be effective, Molly must have a way to find Alice&rsquo;s email on Bob&rsquo;s encrypted drive. However, in some encrypted file systems, the file&rsquo;s metadata—such as filename, modification time, etc.—is <strong>not encrypted</strong>. With this metadata, Molly could easily find the ciphertext of Alice&rsquo;s email and carry out the attack.</p><hr><h2 id=combining-prgs>Combining PRGs</h2><p>Next, we will discuss two constructions that allow creating new PRGs from old ones. These methods allow for increasing the output space size of the original PRG while preserving its security. Perhaps more important than the constructions themselves is the proof technique, known as the <strong>hybrid argument</strong>. This technique is widely used in modern cryptography.</p><h3 id=parallel-construction>Parallel Construction</h3><p>Suppose $G$ is a PRG defined on $(\mathcal{S}, \mathcal{R})$. Suppose in some application, we want to use $G$ multiple times. We want all outputs of $G$ to be computationally indistinguishable from random elements of $\mathcal{R}$. If $G$ is a secure PRG and the seeds are generated independently, this will hold.</p><p>We can model the multiple uses of $G$ as a new PRG $G&rsquo;$. That is, we define a new PRG $G&rsquo;$ that applies $G$ to $n$ different seeds and concatenates the outputs. Then $G&rsquo;$ is defined on $(\mathcal{S}^n, \mathcal{R}^n)$, and for $s_1, \dots, s_n \in \mathcal{S}$:</p><p>$$
G&rsquo;(s_1, \dots, s_n) := (G(s_1), \dots, G(s_n)).
$$</p><p>We call $G&rsquo;$ the <strong>$n$-wise parallel composition</strong> of $G$. The value $n$ is called the <strong>repetition parameter</strong> and is required to be <strong>poly-bounded</strong>.</p><p><strong>Theorem 1.</strong> If $G$ is a secure PRG, then the $n$-wise parallel composition $G&rsquo;$ of $G$ is also a secure PRG.</p><p>That is, for any PRG adversary $\mathcal{A}$ attacking $G&rsquo;$ in the PRG attack game, there exists a PRG adversary $\mathcal{B}$ attacking $G$ in the PRG attack game, where $\mathcal{B}$ is a simple wrapper around $A$, such that:</p><p>$$
\mathtt{PRG}\texttt{adv}[\mathcal{A}, G&rsquo;] = n \cdot \mathtt{PRG}\texttt{adv}[\mathcal{B}, G].
$$</p><hr><h4 id=proof-for-the-case-n--2>Proof for the case n = 2</h4><p>Suppose $\mathcal{A}$ is an efficient PRG adversary with advantage $\epsilon$ in attacking $G&rsquo;$ in the PRG attack game. We want to show that $\epsilon$ is <strong>negligible</strong> if $G$ is a secure PRG.</p><p><strong>Game 0</strong> (experiment 0 of the PRG attack game with $A$ and $G&rsquo;$):</p><ul><li>$s_1 \xleftarrow{R} \mathcal{S}$, $r_1 \leftarrow G(s_1)$</li><li>$s_2 \xleftarrow{R} \mathcal{S}$, $r_2 \leftarrow G(s_2)$</li><li>Send $(r_1, r_2)$ to $\mathcal{A}$.</li></ul><p>Let $p_0$ be the probability that $\mathcal{A}$ outputs $1$ in this game.</p><p><strong>Game 1</strong> (hybrid experiment):</p><ul><li>$r_1 \xleftarrow{R} \mathcal{R}$</li><li>$s_2 \xleftarrow{R} \mathcal{S}$, $r_2 \leftarrow G(s_2)$</li><li>Send $(r_1, r_2)$ to $\mathcal{A}$.</li></ul><p>Game 1 does not correspond fully to either Experiment 0 or 1, but is a hybrid experiment: $r_1$ is changed from a pseudorandom value to a truly random one.</p><p>Let $p_1$ be the probability that $\mathcal{A}$ outputs $1$ in Game 1 and set $\delta_1 := |p_1 - p_0|$. If $G$ is secure, $\delta_1$ is negligible.</p><blockquote><p>Since $\mathcal{A}$ is just a distinguisher for &ldquo;pseudorandom&rdquo; vs. &ldquo;random,&rdquo; it will output 1 if, by its criteria, the pair $(r_1, r_2)$ looks like a pair where both are from the PRG (like Game 0).</p><ul><li>If $\mathcal{A}$ cannot distinguish, its rate of outputting 1 will be close to that in Game 0.</li><li>If $\mathcal{A}$ recognizes that $r_1$ is truly random or that the pair $(r_1, r_2)$ was not generated from a pair of PRGs (like Game 0), it will tend to output 1 less often.</li></ul></blockquote><p>We define an adversary $\mathcal{B}_1$ against $G$:</p><ul><li>Receive $r \in \mathcal{R}$ from its challenger.</li><li>Set $r_1 \leftarrow r$.</li><li>Generate $s_2 \xleftarrow{R} \mathcal{S}$, $r_2 \leftarrow G(s_2)$.</li><li>Send $(r_1, r_2)$ to $\mathcal{A}$.</li><li>Output the result of $\mathcal{A}$.</li></ul><p>When $\mathcal{B}_1$ is in Experiment 0, it simulates Game 0; when in Experiment 1, it simulates Game 1. Therefore, the advantage of $\mathcal{B}_1$ is equal to $\delta_1$.</p><p><strong>Game 2</strong>:</p><ul><li>$r_1 \xleftarrow{R} \mathcal{R}$</li><li>$r_2 \xleftarrow{R} \mathcal{R}$</li><li>Send $(r_1, r_2)$ to $\mathcal{A}$.</li></ul><p>Let $p_2$ be the probability that $\mathcal{A}$ outputs $1$ in Game 2. Game 2 is exactly Experiment 1 of the PRG attack game against $G&rsquo;$.</p><p>Set $\delta_2 := |p_2 - p_1|$. Similarly, we can define a $\mathcal{B}_2$ such that its advantage is $\delta_2$.</p><p>Since $\epsilon = |p_2 - p_0| = |p_2 - p_1 + p_1 - p_0| \le |p_2 - p_1| + |p_1 - p_0| = \delta_1 + \delta_2$ and both are negligible, $\epsilon$ is also negligible.</p><hr><h4 id=a-second-proof-for-n--2>A Second Proof for n = 2</h4><p>Combine $\mathcal{B}_1$ and $\mathcal{B}_2$ into a single adversary $\mathcal{B}$:</p><ul><li>Receive $r \in \mathcal{R}$ from the challenger.</li><li>Choose $\omega \in {1, 2}$ uniformly at random.</li><li>Run $\mathcal{B}_{\omega}$ with input $r$ (pass $r$ to $\mathcal{B}_{\omega}$).</li><li>Output the result of $\mathcal{B}_\omega$.</li></ul><p>Letting $W_0$ and $W_1$ be the events that $\mathcal{B}$ outputs $1$ in Experiment 0 and 1, respectively, we have:</p><p>$$
\begin{aligned}
\Pr[W_0]
&= \Pr[W_0 \mid \omega = 1] \Pr[\omega = 1] + \Pr[W_0 \mid \omega = 2] \Pr[\omega = 2] \\
&= \frac{1}{2} \left( \Pr[W_0 \mid \omega = 1] + \Pr[W_0 \mid \omega = 2] \right) \\
&= \frac{1}{2} (p_0 + p_1)
\end{aligned}
$$</p><p>and</p><p>$$
\begin{aligned}
\Pr[W_1]
&= \Pr[W_1 \mid \omega = 1] \Pr[\omega = 1] + \Pr[W_1 \mid \omega = 2] \Pr[\omega = 2] \\
&= \frac{1}{2} \left( \Pr[W_1 \mid \omega = 1] + \Pr[W_1 \mid \omega = 2] \right) \\
&= \frac{1}{2} (p_1 + p_2).
\end{aligned}
$$</p><p>Thus, the advantage of $\mathcal{B}$ is:</p><p>$$
\delta = \left|\Pr[W_1] - \Pr[W_0]\right| = \frac{|p_2 - p_0|}{2} = \frac{\epsilon}{2}.
$$</p><p>Therefore, $\epsilon = 2\delta$, and since $\delta$ is negligible, $\epsilon$ must also be negligible.</p><hr><p>Now, we finally present the proof of <strong>Theorem 1</strong> for the general case where $n$ is bounded by a polynomial.</p><p><strong>Proof Idea.</strong> We can try to extend the first strategy mentioned above from $n = 2$ to an arbitrary $n$. In other words, we can construct a sequence of $n + 1$ games, starting with a challenger generating a sequence $(G(s_1), \dots, G(s_n))$ of pseudorandom elements, then replacing each element one by one with a truly random element from $\mathcal{R}$, and ending with the sequence $(r_1, \dots, r_n)$ of entirely truly random elements from $\mathcal{R}$.</p><p>The hope is that the adversary will not detect any single replacement, since $G$ is a secure PRG; however, to prove this formally, we would need to construct $n$ different adversaries, each attacking a slightly different variant of $G$. This is challenging when $n$ is not an absolute constant but only poly-bounded.</p><hr><p><strong>Proof.</strong> Let $\mathcal{A}$ be an efficient PRG adversary playing the <strong>PRG attack game</strong> with $G&rsquo;$.</p><p>First, we introduce a sequence of $n + 1$ <strong>hybrid games</strong>: $\text{Hybrid } 0, \text{Hybrid } 1, \dots, \text{Hybrid } n.$</p><p>For $j = 0, 1, \dots, n$, <strong>Hybrid $j$</strong> is a game between $\mathcal{A}$ and a challenger, who prepares an $n$-tuple of values where the first $j$ values are <strong>truly random</strong>, and the remaining $n - j$ values are <strong>pseudorandom outputs of $G$</strong>. Specifically:</p><ul><li>$r_1 \xleftarrow{R} \mathcal{R}$
$\vdots$</li><li>$r_j \xleftarrow{R} \mathcal{R}$</li><li>$s_{j+1} \xleftarrow{R} \mathcal{S}$, $r_{j+1} \leftarrow G(s_{j+1})$
$\vdots$</li><li>$s_n \xleftarrow{R} \mathcal{S}$, $r_n \leftarrow G(s_n)$</li><li>Send $(r_1, \dots, r_n)$ to $\mathcal{A}$.</li></ul><p>As usual, $\mathcal{A}$ outputs $0$ or $1$ at the end of the game.</p><p>Let $p_j$ be the probability that $\mathcal{A}$ outputs $1$ in <strong>Hybrid $j$</strong>.
Observe that $p_0$ is precisely the probability that $\mathcal{A}$ outputs $1$ in <strong>Experiment 0</strong> of the PRG attack game, while $p_n$ is the probability that $\mathcal{A}$ outputs $1$ in <strong>Experiment 1</strong>.</p><p>Therefore:</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{A}, G&rsquo;] = |p_n - p_0|. \tag{2}
$$</p><hr><p>Now, we define a PRG adversary $\mathcal{B}$ that plays the <strong>PRG attack game</strong> against $G$, operating as follows:</p><ul><li><p>Receive $r \in \mathcal{R}$ from its challenger.</p></li><li><p>$\mathcal{B}$ acts as a challenger to $\mathcal{A}$:</p><ul><li>Choose $\omega \xleftarrow{R} {1, \dots, n}$.</li><li>Generate $r_1, \dots, r_{\omega-1} \xleftarrow{R} \mathcal{R}$.</li><li>Set $r_\omega \leftarrow r$.</li><li>Generate $s_{\omega+1} \xleftarrow{R} \mathcal{S}$, $r_{\omega+1} \leftarrow G(s_{\omega+1})$, and so on up to $r_n$.</li><li>Send $(r_1, \dots, r_n)$ to $\mathcal{A}$.</li></ul></li><li><p>Finally, $\mathcal{B}$ outputs whatever $\mathcal{A}$ outputs.</p></li></ul><hr><p>Let $W_0$ be the event that $\mathcal{B}$ outputs $1$ in <strong>Experiment 0</strong> and $W_1$ be the event that $\mathcal{B}$ outputs $1$ in <strong>Experiment 1</strong>.</p><p>The key observation is:</p><ul><li>When fixing $\omega = j$ for some $j \in {1, \dots, n}$, <strong>Experiment 0</strong> of the attack game for $\mathcal{B}$ is equivalent to <strong>Hybrid $j-1$</strong>.</li><li>And <strong>Experiment 1</strong> is equivalent to <strong>Hybrid $j$</strong>.</li></ul><p>Therefore:</p><p>$$
\Pr[W_0 \mid \omega = j] = p_{j-1}, \quad \Pr[W_1 \mid \omega = j] = p_j.
$$</p><p>It follows that:</p><p>$$
\Pr[W_0] = \sum_{j=1}^n \Pr[W_0 \mid \omega = j] \Pr[\omega = j]
= \frac{1}{n} \sum_{j=1}^n p_{j-1},
$$</p><p>and similarly:</p><p>$$
\Pr[W_1] = \sum_{j=1}^n \Pr[W_1 \mid \omega = j] \Pr[\omega = j]
= \frac{1}{n} \sum_{j=1}^n p_j.
$$</p><hr><p>Finally:</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{B}, G] = \left| \Pr[W_1] - \Pr[W_0] \right|
= \frac{1}{n} \left| \sum_{j=1}^n p_j - \sum_{j=1}^n p_{j-1} \right| = \frac{1}{n} \left| p_n - p_0 \right|.
$$</p><p>Combining this with $(2)$ gives:</p><p>$$
\mathtt{PRG}\text{adv}[\mathcal{A}, G&rsquo;] = n \cdot \mathtt{PRG}\text{adv}[\mathcal{B}, G].
$$</p><p>Since we assume $G$ is a secure PRG, $\mathtt{PRG}\text{adv}[\mathcal{B}, G]$ is negligible. As $n$ is poly-bounded, it follows that $\mathtt{PRG}\text{adv}[\mathcal{A}, G&rsquo;]$ is also negligible. This proves the theorem. $\square$</p><hr><p>Throughout this post, we have journeyed from the practical pitfalls of stream ciphers to the solid theoretical foundations for proving security. The core lesson is that cryptographic security depends not only on the algorithm itself but also on its correct implementation and usage. The &ldquo;two-time pad&rdquo; serves as a stark warning about the importance of key management, while malleability underscores that integrity is just as crucial as confidentiality. Finally, the &ldquo;hybrid argument&rdquo; technique is not merely an academic exercise but an essential tool demonstrating how cryptographers build confidence in complex systems through rigorous proof. Understanding both sides of this coin—attacks and proofs—is a critical step toward mastering the art of cryptography.</p><h2 id=references>References</h2><ol><li>Dan Boneh and Victor Shoup. <em>A Graduate Course in Applied Cryptography</em>. Retrieved from <a href=https://toc.cryptobook.us/>https://toc.cryptobook.us/</a></li></ol><h2 id=connect-with-me>Connect with Me</h2><p>Connect with me on <a href=https://www.facebook.com/dangduongminhnhat/>Facebook</a>, <a href=https://www.linkedin.com/in/nhatdang1901/>LinkedIn</a>, via email at <a href=mailto:dangduongminhnhat2003@gmail.com>dangduongminhnhat2003@gmail.com</a>, <a href=https://github.com/dangduongminhnhat>GitHub</a>, or by phone at <a href=tel:+84829258815>+84 829 258 815</a>.</p><div class=blog-tags><a href=https://dangduongminhnhat.github.io/tags/cryptography/>Cryptography</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/stream-cipher/>Stream Cipher</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/cybersecurity/>CyberSecurity</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://dangduongminhnhat.github.io/posts/cryptography/p4/ data-toggle=tooltip data-placement=top title="Cryptography 4: Constructing Secure Stream Ciphers from PRGs">&larr; Previous Post</a></li><li class=next><a href=https://dangduongminhnhat.github.io/posts/cryptography/p6/ data-toggle=tooltip data-placement=top title="Cryptography 6: Can't predict the next bit? Your PRG is secure!">Next Post &rarr;</a></li></ul><div id=utterances-comments><script src=https://utteranc.es/client.js repo=dangduongminhnhat/dangduongminhnhat.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"></ul><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2025
&nbsp;&bull;&nbsp;
<a href=https://dangduongminhnhat.github.io/>Daminha Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.129.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/load-photoswipe.js></script></body></html>