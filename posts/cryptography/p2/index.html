<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Cryptography 2: Semantic Security Prevents Message Recovery Attacks — A Security Reduction Proof - Daminha Blog</title>
<meta name=description content="This blog introduces the notion of message recovery attacks, defines the corresponding security game, and proves that semantic security implies message recovery security via a black-box reduction. A semantic adversary is constructed by wrapping around a message recovery adversary, showing that any success in message recovery would contradict semantic security. This sets the stage for future reductions that interrelate various cryptographic security notions."><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Daminha Blog","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p2\/","name":"Cryptography 2 semantic security prevents message recovery attacks — a security reduction proof"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Dang Duong Minh Nhat"},"headline":"Cryptography 2: Semantic Security Prevents Message Recovery Attacks — A Security Reduction Proof","description":"This blog introduces the notion of message recovery attacks, defines the corresponding security game, and proves that semantic security implies message recovery security via a black-box reduction. A semantic adversary is constructed by wrapping around a message recovery adversary, showing that any success in message recovery would contradict semantic security. This sets the stage for future reductions that interrelate various cryptographic security notions.","inLanguage":"en","wordCount":3831,"datePublished":"2025-04-08T18:47:20\u002b07:00","dateModified":"2025-04-08T18:47:20\u002b07:00","image":"https:\/\/dangduongminhnhat.github.io\/","keywords":["Cryptography, Semantic Security, Message Recovery, Security Reduction"],"mainEntityOfPage":"https:\/\/dangduongminhnhat.github.io\/posts\/cryptography\/p2\/","publisher":{"@type":"Organization","name":"https:\/\/dangduongminhnhat.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/dangduongminhnhat.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Cryptography 2: Semantic Security Prevents Message Recovery Attacks — A Security Reduction Proof"><meta property="og:description" content="This blog introduces the notion of message recovery attacks, defines the corresponding security game, and proves that semantic security implies message recovery security via a black-box reduction. A semantic adversary is constructed by wrapping around a message recovery adversary, showing that any success in message recovery would contradict semantic security. This sets the stage for future reductions that interrelate various cryptographic security notions."><meta property="og:url" content="https://dangduongminhnhat.github.io/posts/cryptography/p2/"><meta property="og:type" content="website"><meta property="og:site_name" content="Daminha Blog"><meta name=twitter:title content="Cryptography 2: Semantic Security Prevents Message Recovery Attacks — …"><meta name=twitter:description content="This blog introduces the notion of message recovery attacks, defines the corresponding security game, and proves that semantic security implies message recovery security via a black-box reduction. A …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.129.0"><link rel=alternate href=https://dangduongminhnhat.github.io/index.xml type=application/rss+xml title="Daminha Blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/syntax.css><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><script async src="https://www.googletagmanager.com/gtag/js?id=G-V19WW5WSEZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-V19WW5WSEZ")}</script><link rel=apple-touch-icon sizes=180x180 href=/favicon_io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon_io/favicon-16x16.png><link rel=manifest href=/favicon_io/site.webmanifest><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      processEscapes: true
    }
  });
</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=google-site-verification content="ors8seNeA2TL4hvELynbBtrr4PwXapoPh2td6zTadCU"><meta name=google-site-verification content="oQJmyNtEP9HjjEcXwRno2_YPeuLd5kX3jTltynIx65s"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://dangduongminhnhat.github.io/>Daminha Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=About href=/posts/about-me/>About</a></li><li><a title=Tags href=/tags/>Tags</a></li><li><a title="Cryptography Series" href=/posts/cryptography/>Cryptography Series</a></li><li><a title=Note href=https://hackmd.io/@daminha>Note</a></li><li><a title=Blog href=/>Blog</a></li></ul></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=posts-heading><h1>Cryptography 2: Semantic Security Prevents Message Recovery Attacks — A Security Reduction Proof</h1><hr class=small></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p><strong>Posted on:</strong> April 8, 2025 |
<strong>Reading time:</strong> 18 minutes |
<strong>Word count:</strong> 3831 words |
<strong>Author:</strong> Dang Duong Minh Nhat</p><p>Hello and welcome back to Part 2 of this cryptography series! If you haven’t already, I highly recommend reading <a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/>Part 1</a> before diving in, as it lays the groundwork for everything we’ll cover here.</p><p>In this post, we’ll explore the concept of <strong>computational encryption schemes</strong>, dig into the formal definition of <strong>semantic security</strong>, and analyze a specific type of attack known as a <strong>message recovery attack</strong>. Most importantly, we’ll prove a fundamental result: that <strong>semantic security inherently protects against message recovery</strong>—and we’ll do it using one of cryptography’s most powerful proof techniques: <strong>security reductions</strong>.</p><p>Let’s get started.</p><hr><h2 id=computational-ciphers-and-semantic-security><strong>Computational Ciphers and Semantic Security</strong></h2><p>As we already know from Shannon&rsquo;s theorem (Theorem 4 in the blog post <a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/>Cryptography 1</a>), the only way to achieve <strong>perfect secrecy</strong> is to use a key whose length is equal to that of the message. However, this requirement is impractical in many real-world scenarios. Ideally, we would like to encrypt long messages (e.g., documents that are several megabytes in size) using a short key (e.g., only a few hundred bits).</p><p>The only way to circumvent Shannon’s theorem is to <strong>relax our security requirements</strong>. We do so by restricting our attention to <strong>computationally bounded adversaries</strong> — attackers in the real world who can only perform computations within reasonable time and memory constraints on actual hardware. This shift in perspective leads to a weaker, yet still meaningful, definition of security called <strong>semantic security</strong>.</p><p>Moreover, our new security definition is designed to be <strong>flexible</strong>: it allows encryption schemes with variable-length message spaces to still be considered secure, <strong>as long as</strong> they leak no useful information about the plaintext message to the adversary — other than possibly the length of the message. Since our focus is now on <strong>practical security</strong> rather than <strong>information-theoretic guarantees</strong>, we additionally require that both the encryption and decryption algorithms be <strong>efficient</strong>, i.e., computable in polynomial time.</p><h3 id=definition-of-computational-ciphers><strong>Definition of Computational Ciphers</strong></h3><p>A <strong>computational cipher</strong> $\mathcal{E} = (E, D)$ consists of a pair of efficient algorithms $E$ and $D$:</p><ul><li>The encryption algorithm $E$ takes a key $k$ and a message $m$ as input, and outputs a ciphertext $c$.</li><li>The decryption algorithm $D$ takes a key $k$ and a ciphertext $c$ as input, and outputs the message $m$.</li></ul><p>The key belongs to a <strong>finite key space</strong> $\mathcal{K}$, the messages to a <strong>finite message space</strong> $\mathcal{M}$, and the ciphertexts to a <strong>finite ciphertext space</strong> $\mathcal{C}$. Similar to Shannon&rsquo;s ciphers, we say that $\mathcal{E}$ is defined over the triple $\left( \mathcal{K}, \mathcal{M}, \mathcal{C} \right)$.</p><h3 id=probabilistic-encryption>Probabilistic Encryption</h3><p>We say that the encryption algorithm $E$ is probabilistic, meaning that for a fixed key $k$ and message $m$, the output of $E(k, m)$ can vary across multiple executions. To emphasize the randomness in the encryption process, we write</p><p>$$
c \xleftarrow{R} E(k, m)
$$</p><p>which denotes executing $E(k, m)$ and assigning its (random) output to variable $c$.</p><p>Similarly, to represent selecting a random key from the key space $\mathcal{K}$, we write</p><p>$$
k \xleftarrow{R} \mathcal{K}
$$</p><p>to denote that $k$ is chosen uniformly at random from $\mathcal{K}$.</p><p>Although the decryption algorithm could, in principle, be probabilistic, we will <strong>not</strong> focus on that here (this possibility will be revisited later). Therefore, we consider only encryption schemes with <strong>deterministic decryption algorithms</strong>. Nevertheless, we sometimes allow the decryption algorithm to return a special value (distinct from any valid message) to indicate a decryption error.</p><h3 id=correctness-of-decryption>Correctness of Decryption</h3><p>Since the encryption algorithm is probabilistic, it may output different ciphertexts for the same key $k$ and message $m$ on different executions. However, <strong>every ciphertext produced must decrypt correctly back to the original message</strong>. We formalize this requirement as follows: for every $k \in \mathcal{K}$ and every $m \in \mathcal{M}$, if</p><p>$$
c \xleftarrow{R} E(k, m), \quad m&rsquo; \leftarrow D(k, c),
$$</p><p>then it must hold that</p><p>$$
\Pr\left[ D(k, c) = m \mid c \xleftarrow{R} E(k, m) \right] = 1.
$$</p><p>From now on, whenever we refer to an encryption scheme, we implicitly mean a <strong>computational cipher</strong> as defined above. If the encryption algorithm is deterministic, we refer to the scheme as a <strong>deterministic cipher</strong>.</p><h3 id=comparison-with-shannon-ciphers>Comparison with Shannon Ciphers</h3><p>Note that every <strong>deterministic cipher</strong> is also a <strong>Shannon cipher</strong>. However, a <strong>computational cipher</strong> is not necessarily a Shannon cipher (if its encryption algorithm is probabilistic), and conversely, a <strong>Shannon cipher</strong> is not necessarily a computational cipher (if it lacks efficient encryption or decryption algorithms). Let&rsquo;s revisit some examples from <a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/>Cryptography 1</a>:</p><ul><li>The <strong>one-time pad</strong> and <strong>variable-length one-time pad</strong> are both <strong>deterministic ciphers</strong>, since their encryption and decryption can be implemented easily using efficient deterministic algorithms.</li><li>The <strong>substitution cipher</strong> is also a <strong>deterministic cipher</strong>, as long as the size of the alphabet $\Sigma$ is not too large. In practice, a key (a permutation of $\Sigma$) is often represented as an array indexed by the characters in $\Sigma$, requiring $O(|\Sigma|)$ storage. This is only practical when $\Sigma$ is of reasonable size.</li><li>The <strong>additive one-time pad</strong> is likewise a <strong>deterministic cipher</strong>, since both encryption and decryption operations are efficient. For large values of $n$, special-purpose software may be needed to perform arithmetic over large integers.</li></ul><h3 id=definition-of-semantic-security><strong>Definition of Semantic Security</strong></h3><p>We now delve deeper into the definition of semantic security. Consider a deterministic encryption scheme $\mathcal{E} = (E, D)$ defined over the tuple $(\mathcal{K}, \mathcal{M}, \mathcal{C})$. Recall <strong>Theorem 2</strong> on perfect secrecy from <a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/>Cryptography 1</a>, which states:</p><p>$$
\Pr[\phi(E(\mathbf{k}, m_0))] = \Pr[\phi(E(\mathbf{k}, m_1))]
$$</p><p>where $\mathbf{k}$ is a random variable uniformly sampled from the key space $\mathcal{K}$.</p><p>Instead of requiring these two probabilities to be <strong>exactly equal</strong>, we now relax the condition and only require them to be <strong>very close</strong>, that is:</p><p>$$
\left| \Pr[\phi(E(\mathbf{k}, m_0))] - \Pr[\phi(E(\mathbf{k}, m_1))] \right| \leq \epsilon
$$</p><p>for some small (possibly negligible) value $\epsilon$.</p><p>However, this condition is still too strict. Rather than requiring it to hold for <strong>all</strong> choices of messages $m_0, m_1$ and functions $\phi$, we only require it to hold for:</p><ul><li>message pairs $m_0, m_1$ generated by <strong>efficient algorithms</strong>, and</li><li>functions $\phi$ that are also <strong>efficiently computable</strong> (these algorithms may be probabilistic).</li></ul><p>For example, suppose that even using the <strong>most powerful algorithms</strong> running on <strong>10,000 machines in parallel for 10 years</strong>, the inequality above still holds with $\epsilon = 2^{-100}$. In such a case, the scheme may not be <strong>perfectly secure</strong>, but we may still consider it to be <strong>secure in practice</strong>.</p><p>Furthermore, this relaxed definition of semantic security also addresses issues such as the <strong>variable-length one-time pad</strong>, which fails to achieve perfect secrecy as shown in <a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/>Cryptography 1</a>. Our goal is to have a flexible definition that can still regard such schemes as secure—<strong>as long as they leak no information about the message except its length</strong>.</p><p>Let us now proceed to formalize the notion of <strong>semantic security</strong> through an <strong>attack game</strong> involving two parties:</p><ul><li>the <strong>challenger</strong>, and</li><li>the <strong>adversary</strong>.</li></ul><p>We define different attack games to capture various levels of security. In these games:</p><ul><li>The <strong>challenger</strong> follows a fixed protocol.</li><li>The <strong>adversary</strong> may employ any strategy, as long as it is computationally efficient.</li><li>The two parties interact via a defined protocol, and in the end, the adversary outputs a <strong>guess</strong>.</li></ul><p>Each attack game defines a <strong>probability space</strong>, from which we compute the <strong>adversary’s advantage</strong> based on the probability of certain events. Some games are modeled using two separate <strong>experiments</strong>:</p><ul><li>In both experiments, the adversary follows the same strategy.</li><li>However, the <strong>challenger’s behavior</strong> differs in each experiment.</li></ul><p>Specifically:</p><ol><li>The adversary selects two messages $m_0, m_1$ of equal length and sends them to the challenger.</li><li>The challenger performs one of the following two experiments:<ul><li><strong>Experiment 0</strong>: Encrypts $m_0$ using a randomly chosen key.</li><li><strong>Experiment 1</strong>: Encrypts $m_1$ using a randomly chosen key.</li></ul></li><li>The challenger returns the resulting ciphertext $c$ to the adversary.</li><li>The adversary analyzes $c$ and attempts to guess which message was encrypted, outputting a bit $\hat{b} \in \left\lbrace 0, 1 \right\rbrace$.</li></ol><p>Let’s now define the <strong>Semantic Security Game</strong> formally. Given an encryption scheme $\mathcal{E} = (E, D)$ defined over $(\mathcal{K}, \mathcal{M}, \mathcal{C})$ and an adversary $\mathcal{A}$, we define two experiments: <strong>Experiment 0</strong> and <strong>Experiment 1</strong>. For $b \in \left\lbrace 0, 1 \right\rbrace$, <strong>Experiment b</strong> is defined as follows:</p><ol><li>The adversary chooses two messages $m_0, m_1 \in \mathcal{M}$ of equal length and sends them to the challenger.</li><li>The challenger performs the following steps:<ul><li>Samples a random key: $k \xleftarrow{R} \mathcal{K}$</li><li>Encrypts message $m_b$: $c \xleftarrow{R} E(k, m_b)$</li><li>Sends the ciphertext $c$ to the adversary</li></ul></li><li>The adversary observes $c$ and outputs a guess bit $\hat{b} \in \left\lbrace 0, 1 \right\rbrace$.</li></ol><p>To visualize this, refer to the diagram below:</p><p><img src=/images/cryptography/p2/diagram.png alt=image></p><h4 id=definition-of-adversarys-advantage>Definition of Adversary’s Advantage</h4><p>Let $W_b$ denote the event that adversary $\mathcal{A}$ outputs $\hat{b} = 1$ in <strong>Experiment b</strong>. Then, the advantage of $\mathcal{A}$ in breaking the semantic security of the encryption scheme $\mathcal{E}$ is defined as:</p><p>$$
\mathtt{SS}\text{adv}[\mathcal{A},\mathcal{E}] := \left| \Pr[W_0] - \Pr[W_1] \right|.
$$</p><p>In the above attack game, the events $W_0$ and $W_1$ are defined over a probability space that depends on:</p><ul><li>The random choice of the key $k$.</li><li>The internal randomness (if any) of the encryption algorithm.</li><li>The randomness (if any) used by the adversary.</li></ul><p>The value $\mathtt{SS}\text{adv}[\mathcal{A},\mathcal{E}]$ always lies in the interval $[0,1]$. If this value is very small, it indicates that the adversary cannot distinguish between the ciphertexts of $m_0$ and $m_1$, thereby preserving the semantic security of the encryption scheme.</p><h4 id=definition-semantic-security>Definition (Semantic Security)</h4><p>An encryption scheme $\mathcal{E}$ is said to be <strong>semantically secure</strong> if for every efficient adversary $\mathcal{A}$, the value $\mathtt{SS}\text{adv}[\mathcal{A},\mathcal{E}]$ is <strong>negligible</strong>. This definition, however, is not yet fully rigorous, since the notions of “messages of the same length,” “efficient adversary,” and “negligible function” have not been precisely defined. We will revisit these notions later.</p><p>Assume that the adversary $\mathcal{A}$ in the <strong>Semantic Security Attack Game</strong> is <strong>deterministic</strong>. Then:</p><ol><li>$\mathcal{A}$ chooses two messages $m_0, m_1$ deterministically.</li><li>$\mathcal{A}$ evaluates a <strong>predicate</strong> $\phi$ on the ciphertext $c$ and outputs $1$ if true, and $0$ otherwise.</li></ol><p>Semantic security requires that the value $\epsilon$ in the inequality</p><p>$$
\left| \Pr[\phi(E(k, m_0))] - \Pr[\phi(E(k, m_1))] \right| \leq \epsilon
$$</p><p>is <strong>negligible</strong>.</p><p>If $\mathcal{A}$ is a <strong>randomized algorithm</strong>, we can model it as follows:</p><ol><li>Sample a random value $r$ from some suitable distribution.</li><li>Determine two messages $m_0^{(r)}$, $m_1^{(r)}$ based on $r$.</li><li>Evaluate a predicate $\phi^{(r)}$ on $c$, which may also depend on $r$.</li></ol><p>In this case, semantic security requires that the value $\epsilon$ in the inequality above (now applied to $m_0^{(r)}, m_1^{(r)}, \phi^{(r)}$) is negligible—where the probability is taken over the randomness of both the encryption key and the random value $r$.</p><hr><p>We now make several observations about the requirement that the two messages $m_0$ and $m_1$ selected by the adversary in the <strong>Semantic Security Attack Game</strong> must have equal length.</p><ul><li><p><strong>First</strong>, the concept of “length” for a message depends on the message space $\mathcal{M}$.</p><ul><li>When defining a message space, we also need to define a function that assigns a non-negative integer length to each message.</li><li>In many practical cases, this is straightforward. For example, in $\left\lbrace 0,1 \right\rbrace^{\leq L}$, the length of a message $m \in \left\lbrace 0,1 \right\rbrace^{\leq L}$ is simply the number of bits it contains, denoted $|m|$.</li><li>However, for generality, we leave the notion of length <strong>abstract</strong>, without assigning a fixed rule.</li><li>In certain message spaces, the notion of length may not exist, in which case we can assume that <strong>all messages have length zero</strong>.</li></ul></li><li><p><strong>Second</strong>, the requirement that $m_0$ and $m_1$ have the same length ensures that an adversary cannot trivially break the encryption by distinguishing ciphertexts based solely on message lengths.</p><ul><li>Without this requirement, an encryption scheme might be considered <strong>insecure</strong> simply because it leaks the message length.</li><li>This reflects the reality that most practical encryption schemes <strong>do allow leakage of message length</strong>, but they should not leak any <strong>content</strong> of the message.</li></ul></li></ul><p>Let us revisit the <strong>variable-length one-time pad</strong> example from <a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/>Cryptography 1</a>, where leakage of message length can have serious consequences in some applications. However, since <strong>there is no general solution</strong> to hide message lengths, most real-world schemes (e.g., <strong>TLS</strong>) do not attempt to conceal this information. This has led to practical attacks, and in some sensitive contexts, <strong>ciphertext length leakage can be a severe security risk</strong>.</p><p>Nonetheless, semantic security is typically assumed to be <strong>independent of message length</strong>, so let us consider the following example. Suppose $\mathcal{E}$ is a <strong>deterministic encryption scheme</strong> with <strong>perfect security</strong>. Then it is easy to see that <strong>for all adversaries $\mathcal{A}$, efficient or otherwise</strong>, we have:</p><p>$$
\mathtt{SS}\text{adv}[\mathcal{A},\mathcal{E}] = 0.
$$</p><p>This follows almost immediately from <strong>Theorem 2</strong> in <a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/>Cryptography 1</a> (with the minor caveat that $\mathcal{A}$ in the semantic security game may be randomized, but this is easy to address). Therefore, the encryption scheme $\mathcal{E}$ is <strong>semantically secure</strong>. Specifically:</p><ul><li>If $\mathcal{E}$ is the <strong>one-time pad</strong>, then $\mathtt{SS}\text{adv}[\mathcal{A},\mathcal{E}] = 0$ for all $\mathcal{A}$. In other words, <strong>the one-time pad is semantically secure</strong>.</li><li>As noted earlier, since the definition of semantic security assumes that the adversary cannot break the scheme by distinguishing ciphertext lengths, it is also easy to show that if $\mathcal{E}$ is the <strong>variable-length one-time pad</strong>, then again $\mathtt{SS}\text{adv}[\mathcal{A},\mathcal{E}] = 0$ for all $\mathcal{A}$. That is, <strong>the variable-length one-time pad is also semantically secure</strong>.</li></ul><hr><p>Before proceeding, let me first clarify two important notions: <strong>&ldquo;efficient&rdquo;</strong> and <strong>&ldquo;negligible&rdquo;</strong>. While we will study these concepts more formally in later sections, here is a simple intuitive explanation:</p><ul><li><p>A function is <strong>negligible</strong> if its value is <strong>so small that it can be considered practically zero</strong>. For example, consider the value $2^{-100}$. If the probability that you spontaneously combust in the next year is $2^{-100}$, then you would not worry about that event any more than you would worry about an event with <strong>probability $0$</strong>.</p></li><li><p>An <strong>efficient adversary</strong> refers to one that runs in a &ldquo;reasonable&rdquo; amount of time. Formally, its running time is bounded by a polynomial function of the input size. In other words, it cannot take more than a polynomial number of steps in the size of its input.</p></li></ul><p>Rather than diving into technical details, let us walk through an <strong>example</strong> that illustrates how this definition is used to analyze the security of a larger system that employs a semantically secure encryption scheme.</p><h2 id=message-recovery-attack><strong>Message Recovery Attack</strong></h2><p>As our first example, we consider a <strong>Message Recovery (MR) attack</strong>, in which an adversary is given a ciphertext corresponding to a random message and attempts to <strong>recover the original message with significantly better probability than random guessing</strong>, that is, <strong>better than $1 / |\mathcal{M}|$</strong>. Clearly, any reasonable notion of security should prevent such attacks—including <strong>semantic security</strong>.</p><p>Although this may seem obvious (after all, if the adversary cannot distinguish between $m_0$ and $m_1$, it certainly cannot recover a random message), we will provide a formal proof. This will also serve as a detailed example of the technique called <strong>security reduction</strong>, which is the primary method used to argue the security of cryptographic systems.</p><p>The core idea of a security reduction is as follows: suppose there exists an <strong>efficient adversary $\mathcal{A}$</strong> that succeeds in a message recovery attack against an encryption scheme $\mathcal{E}$. Then we can <strong>construct an efficient adversary $\mathcal{B}$</strong> that breaks the semantic security of $\mathcal{E}$. Since semantic security implies that no such efficient adversary $\mathcal{B}$ can exist, it follows that no such $\mathcal{A}$ exists either.</p><p>As in semantic security, the attack is modeled by an <strong>interaction between a challenger and an adversary</strong>, forming a security game we call the <strong>Message Recovery game</strong>. The game proceeds as follows for a symmetric encryption scheme $\mathcal{E} = (E, D)$ defined over message space $\mathcal{M}$, key space $\mathcal{K}$, and ciphertext space $\mathcal{C}$:</p><ul><li><p>The challenger samples a message $m \xleftarrow{R} \mathcal{M}$, a key $k \xleftarrow{R} \mathcal{K}$, and computes the ciphertext $c \xleftarrow{R} E(k, m)$. The ciphertext $c$ is sent to the adversary.</p></li><li><p>The adversary outputs a message guess $\hat{m} \in \mathcal{M}$.</p></li></ul><p>Let $W$ denote the event that $\hat{m} = m$, i.e., the adversary correctly recovers the message. We say that $\mathcal{A}$ <strong>wins</strong> the game if $W$ occurs. The <strong>message recovery advantage</strong> of $\mathcal{A}$ against scheme $\mathcal{E}$ is defined as:</p><p>$$
\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}] := \left| \Pr[W] - \frac{1}{|\mathcal{M}|} \right|.
$$</p><h3 id=definition-message-recovery-security><strong>Definition: Message Recovery Security</strong></h3><p>An encryption scheme $\mathcal{E}$ is said to be <strong>secure against message recovery attacks</strong> if, for all efficient adversaries $\mathcal{A}$, the message recovery advantage $\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}]$ is a <strong>negligible function</strong> in the security parameter. That is, the scheme is secure if every efficient adversary has only negligible advantage over random guessing.</p><p>This leads us to the following theorem:</p><hr><p><strong>Theorem 1.</strong> Let $\mathcal{E} = (E, D)$ be an encryption scheme defined over $(\mathcal{K}, \mathcal{M}, \mathcal{C})$. <strong>If $\mathcal{E}$ is semantically secure</strong>, then <strong>$\mathcal{E}$ is also secure against message recovery attacks</strong>.</p><hr><p><strong>Proof.</strong> Suppose $\mathcal{E}$ is semantically secure. Our goal is to prove that $\mathcal{E}$ is also secure against message recovery. That is, we must show that for any efficient adversary $\mathcal{A}$, the message recovery advantage $\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}]$ is negligible.</p><p>Let:</p><ul><li>$p = \Pr[\mathcal{A} \text{ wins the MR game}]$,</li><li>$|\mathcal{M}|$ be the size of the message space.</li></ul><p>Then:</p><p>$$
\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}] = \left| p - \frac{1}{|\mathcal{M}|} \right|.
$$</p><p>We now construct an efficient adversary $\mathcal{B}$ for the semantic security game such that:</p><p>$$
\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}] \leq \texttt{SS}\text{adv}[\mathcal{B}, \mathcal{E}] \tag{1}
$$</p><p>Since $\mathcal{E}$ is semantically secure and $\mathcal{B}$ is efficient, we know that $\texttt{SS}\text{adv}[\mathcal{B}, \mathcal{E}]$ is negligible, and hence so is $\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}]$.</p><p>We treat $\mathcal{A}$ as a <strong>black-box</strong> and build $\mathcal{B}$ as follows:</p><ol><li><p>$\mathcal{B}$ selects two random messages $m_0, m_1 \in \mathcal{M}$ and submits them to its <strong>semantic security challenger</strong>.</p></li><li><p>The challenger returns a ciphertext $c = E(k, m_b)$ where $b \xleftarrow{R} \left\lbrace 0, 1 \right\rbrace$ is random.</p></li><li><p>$\mathcal{B}$ forwards $c$ to $\mathcal{A}$, pretending it was generated in the MR game.</p></li><li><p>$\mathcal{A}$ returns a message guess $\hat{m} \in \mathcal{M}$.</p></li><li><p>$\mathcal{B}$ outputs:</p><ul><li>$\hat{b} = 1$ if $\hat{m} = m_1$,</li><li>$\hat{b} = 0$ otherwise.</li></ul></li></ol><p>This completes the construction of $\mathcal{B}$. Note that the running time of $\mathcal{B}$ is essentially the same as $\mathcal{A}$, since $\mathcal{B}$ simply invokes $\mathcal{A}$ as a subroutine. Now we analyze the advantage of $\mathcal{B}$ in the semantic security game.</p><p>Let:</p><ul><li>$p_1 = \Pr[\mathcal{B} \text{ outputs } \hat{b} = 1 \mid c = E(k, m_1)] = \Pr[\hat{m} = m_1] = p$,</li><li>$p_0 = \Pr[\mathcal{B} \text{ outputs } \hat{b} = 1 \mid c = E(k, m_0)] = \Pr[\hat{m} = m_1] = \frac{1}{|\mathcal{M}|}$.</li></ul><p>Because when $c = E(k, m_1)$, the adversary $\mathcal{A}$ receives the ciphertext from $\mathcal{B}$ and attempts to recover the original message. The probability that $\mathcal{A}$ correctly outputs $m_1$ is exactly the probability of winning in the message recovery game, that is,</p><p>$$
p_1 = \Pr[\hat{m} = m_1] = p.
$$</p><p>On the other hand, when the ciphertext is an encryption of $m_0$, then $\mathcal{A}$ receives a ciphertext corresponding to $m_0$, with no information whatsoever about $m_1$. In this case, $\mathcal{A}$’s attempt to guess $m_1$ amounts to a blind guess. Therefore,</p><p>$$
p_0 = \Pr[\hat{m} = m_1] = \frac{1}{\left|\mathcal{M}\right|}.
$$</p><p>Then:</p><p>$$
\texttt{SS}\text{adv}[\mathcal{B}, \mathcal{E}] = |p_1 - p_0| = \left| p - \frac{1}{|\mathcal{M}|} \right| = \texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}].
$$</p><p>This shows that the inequality (1) holds, and in fact, equality is achieved in this case. However, for the purpose of the reduction, the inequality alone is sufficient.</p><hr><p>You should make sure you understand the logic of this proof, as this type of argument will be used repeatedly throughout this series. Let us now review the key parts of the proof, and present an alternative perspective to think about it.</p><p>At the heart of the proof lies the following proposition: <strong>for every efficient message recovery adversary</strong> $\mathcal{A}$ against $\mathcal{E}$ in the <strong>Message Recovery Attack Game</strong>, there exists an <strong>efficient semantic security adversary</strong> $\mathcal{B}$ against $\mathcal{E}$ in the <strong>Semantic Security Attack Game</strong> such that:</p><p>$$
\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}] \leq \texttt{SS}\text{adv}[\mathcal{B}, \mathcal{E}] \tag{2}
$$</p><p>Our goal is to prove that if $\mathcal{E}$ is <strong>semantically secure</strong>, then it is also <strong>secure against message recovery</strong>.</p><p>In the proof above, we argued that if $\mathcal{E}$ is semantically secure, then the right-hand side of inequality $(2)$ must be <strong>negligible</strong>. This implies that the left-hand side must also be negligible. Since this holds for <strong>every</strong> efficient adversary $\mathcal{A}$, we conclude that $\mathcal{E}$ is secure against message recovery.</p><p>An alternative approach to proving the theorem is to use <strong>contrapositive reasoning</strong>:</p><blockquote><p>If $\mathcal{E}$ is <strong>not</strong> secure against message recovery, then $\mathcal{E}$ is <strong>not</strong> semantically secure.</p></blockquote><p>Specifically, suppose that $\mathcal{E}$ is not message recovery secure. This means that there exists an <strong>efficient adversary</strong> $\mathcal{A}$ whose message recovery advantage is <strong>non-negligible</strong>. Using $\mathcal{A}$, we construct an efficient adversary $\mathcal{B}$ such that inequality $(2)$ holds. Since $\texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}]$ is non-negligible, and by $(2)$ we have $\texttt{SS}\text{adv}[\mathcal{B}, \mathcal{E}] \geq \texttt{MR}\text{adv}[\mathcal{A}, \mathcal{E}]$, it follows that $\texttt{SS}\text{adv}[\mathcal{B}, \mathcal{E}]$ is also non-negligible. Hence, $\mathcal{E}$ is <strong>not</strong> semantically secure. In short:</p><blockquote><p>To prove that <strong>semantic security</strong> implies <strong>message recovery security</strong>, it suffices to show how to convert a message recovery adversary into a semantic security adversary.</p></blockquote><p>It is worth emphasizing that the <strong>adversary $\mathcal{B}$</strong> constructed in the proof <strong>uses $\mathcal{A}$ merely as a black box</strong>. In fact, most constructions we will see later follow this template: $\mathcal{B}$ acts as a <strong>wrapper</strong> around $\mathcal{A}$, providing a simple and efficient <strong>communication interface</strong> between <strong>$\mathcal{B}$’s challenger</strong> and a single execution of $\mathcal{A}$.</p><p>We say that the computational cost of the interface (the data exchanged between $\mathcal{B}$ and $\mathcal{A}$) does not depend on the computational complexity of $\mathcal{A}$. However, in some cases this cannot be completely avoided. For example, if the attack game allows $\mathcal{A}$ to issue multiple queries to the challenger, then the more queries there are, the more work the interface needs to perform. That said, the workload should depend only on the <strong>number of queries</strong>, and <strong>not on the runtime of $\mathcal{A}$</strong>.</p><p>Thus, we define $\mathcal{B}$ to be an <strong>elementary wrapper</strong> around $\mathcal{A}$ if it is constructed in this way, with an efficient interface interacting with $\mathcal{A}$. Key properties of this notion include:</p><ul><li>If $\mathcal{B}$ is an elementary wrapper around $\mathcal{A}$, and $\mathcal{A}$ is efficient, then $\mathcal{B}$ is also efficient.</li><li>If $\mathcal{C}$ is an elementary wrapper around $\mathcal{B}$, and $\mathcal{B}$ is an elementary wrapper around $\mathcal{A}$, then $\mathcal{C}$ is an elementary wrapper around $\mathcal{A}$.</li></ul><p>These concepts will be presented more <strong>formally</strong> in the future.</p><hr><p>In this blog, we clarified the connection between <strong>semantic security</strong> and resistance against <strong>message recovery attacks</strong>. By employing a <strong>security reduction</strong> technique, we demonstrated that any encryption scheme achieving semantic security must also thwart any efficient adversary attempting to recover the original message from a ciphertext.</p><p>This proof exemplifies a fundamental mindset in modern cryptography: <strong>proving that stronger security notions imply weaker ones</strong>, using precise reductions. Specifically, we constructed a <strong>wrapper adversary</strong> that leverages a message recovery attacker as a black-box to break semantic security.</p><p>This style of argument—<strong>black-box reduction via adversary wrapping</strong>—will appear repeatedly throughout this series, serving as a core proof technique. Understanding the logic of this reduction not only solidifies our grasp of semantic security but also lays the groundwork for analyzing more advanced security notions in future posts.</p><h2 id=references>References</h2><ol><li>Dan Boneh and Victor Shoup. <em>A Graduate Course in Applied Cryptography</em>. Retrieved from <a href=https://toc.cryptobook.us/>https://toc.cryptobook.us/</a></li></ol><h2 id=connect-with-me>Connect with Me</h2><p>Connect with me on <a href=https://www.facebook.com/dangduongminhnhat/>Facebook</a>, <a href=https://www.linkedin.com/in/nhatdang1901/>LinkedIn</a>, via email at <a href=mailto:dangduongminhnhat2003@gmail.com>dangduongminhnhat2003@gmail.com</a>, <a href=https://github.com/dangduongminhnhat>GitHub</a>, or by phone at <a href=tel:+84829258815>+84 829 258 815</a>.</p><div class=blog-tags><a href=https://dangduongminhnhat.github.io/tags/cryptography/>Cryptography</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/semantic-security/>Semantic Security</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/message-recovery/>Message Recovery</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/security-reduction/>Security Reduction</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://dangduongminhnhat.github.io/posts/cryptography/p1/ data-toggle=tooltip data-placement=top title="Cryptography 1: Perfect Security and the Limits of Perfect Security">&larr; Previous Post</a></li></ul><div id=utterances-comments><script src=https://utteranc.es/client.js repo=dangduongminhnhat/dangduongminhnhat.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"></ul><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2025
&nbsp;&bull;&nbsp;
<a href=https://dangduongminhnhat.github.io/>Daminha Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.129.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/load-photoswipe.js></script></body></html>