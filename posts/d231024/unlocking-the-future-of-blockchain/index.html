



<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

 


      <title>Unlocking the Future of Blockchain: Exploring ZK-Rollups and zkEVM - Daminha Blog</title>

  <meta name="description" content="This blog provides a comprehensive overview of zk-Rollups and zkEVMs, highlighting their advantages in scalability, data compression, and enhanced privacy. Despite their potential, challenges such as developer unfriendliness and lack of composability hinder widespread adoption. By examining two primary approaches for building decentralized applications (DApps) on zk-Rollups—application-specific circuits and universal EVM circuits—we shed light on the ongoing evolution of Ethereum technology. Ultimately, the zkEVM represents a significant leap forward, merging familiar smart contract execution with the groundbreaking capabilities of zero-knowledge proofs."><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Daminha Blog",
    
    "url": "https:\/\/dangduongminhnhat.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/dangduongminhnhat.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/dangduongminhnhat.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/dangduongminhnhat.github.io\/posts\/d231024\/unlocking-the-future-of-blockchain\/",
          "name": "Unlocking the future of blockchain exploring zk rollups and zk evm"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Dang Duong Minh Nhat"
  },
  "headline": "Unlocking the Future of Blockchain: Exploring ZK-Rollups and zkEVM",
  "description" : "This blog provides a comprehensive overview of zk-Rollups and zkEVMs, highlighting their advantages in scalability, data compression, and enhanced privacy. Despite their potential, challenges such as developer unfriendliness and lack of composability hinder widespread adoption. By examining two primary approaches for building decentralized applications (DApps) on zk-Rollups—application-specific circuits and universal EVM circuits—we shed light on the ongoing evolution of Ethereum technology. Ultimately, the zkEVM represents a significant leap forward, merging familiar smart contract execution with the groundbreaking capabilities of zero-knowledge proofs.",
  "inLanguage" : "en",
  "wordCount":  4613 ,
  "datePublished" : "2024-10-23T12:16:01\u002b07:00",
  "dateModified" : "2024-10-23T12:16:01\u002b07:00",
  "image" : "https:\/\/dangduongminhnhat.github.io\/",
  "keywords" : [ "zkRollups, zkEVM, Ethereum, Blockchain, Zero-Knowledge Proofs" ],
  "mainEntityOfPage" : "https:\/\/dangduongminhnhat.github.io\/posts\/d231024\/unlocking-the-future-of-blockchain\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/dangduongminhnhat.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/dangduongminhnhat.github.io\/",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>


<meta property="og:title" content="Unlocking the Future of Blockchain: Exploring ZK-Rollups and zkEVM" />
<meta property="og:description" content="This blog provides a comprehensive overview of zk-Rollups and zkEVMs, highlighting their advantages in scalability, data compression, and enhanced privacy. Despite their potential, challenges such as developer unfriendliness and lack of composability hinder widespread adoption. By examining two primary approaches for building decentralized applications (DApps) on zk-Rollups—application-specific circuits and universal EVM circuits—we shed light on the ongoing evolution of Ethereum technology. Ultimately, the zkEVM represents a significant leap forward, merging familiar smart contract execution with the groundbreaking capabilities of zero-knowledge proofs.">
<meta property="og:url" content="https://dangduongminhnhat.github.io/posts/d231024/unlocking-the-future-of-blockchain/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Daminha Blog" />

  <meta name="twitter:title" content="Unlocking the Future of Blockchain: Exploring ZK-Rollups and zkEVM" />
  <meta name="twitter:description" content="This blog provides a comprehensive overview of zk-Rollups and zkEVMs, highlighting their advantages in scalability, data compression, and enhanced privacy. Despite their potential, challenges such as …">
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="generator" content="Hugo 0.129.0">
  <link rel="alternate" href="https://dangduongminhnhat.github.io/index.xml" type="application/rss+xml" title="Daminha Blog"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous"><link rel="stylesheet" href="https://dangduongminhnhat.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="https://dangduongminhnhat.github.io/css/syntax.css" /><link rel="stylesheet" href="https://dangduongminhnhat.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">

  

<link rel="apple-touch-icon" sizes="180x180" href="/favicon_io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon_io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon_io/favicon-16x16.png">
<link rel="manifest" href="/favicon_io/site.webmanifest">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full">
</script>
<script type="text/javascript" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


    <meta name="google-site-verification" content="ors8seNeA2TL4hvELynbBtrr4PwXapoPh2td6zTadCU" />
    <meta name="google-site-verification" content="oQJmyNtEP9HjjEcXwRno2_YPeuLd5kX3jTltynIx65s" />
  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://dangduongminhnhat.github.io/">Daminha Blog</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="About" href="/posts/about-me/">About</a>
            </li>
          
        
          
            <li>
              <a title="Tags" href="/tags/">Tags</a>
            </li>
          
        
          
            <li>
              <a title="Cryptography Series" href="/posts/cryptography/">Cryptography Series</a>
            </li>
          
        
          
            <li>
              <a title="Note" href="https://hackmd.io/@daminha">Note</a>
            </li>
          
        
          
            <li>
              <a title="Blog" href="/">Blog</a>
            </li>
          
        

        

        
      </ul>
    </div>

    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="posts-heading">
              
                <h1>Unlocking the Future of Blockchain: Exploring ZK-Rollups and zkEVM</h1>
              
              
                <hr class="small">
              
              
              
            </div>
          </div>
        </div>
      </div>
    </div>
  
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p>
          <strong>Posted on:</strong> October 23, 2024 |
          <strong>Reading time:</strong> 22 minutes |
          <strong>Word count:</strong> 4613 words |
          <strong>Author:</strong> Dang Duong Minh Nhat
        </p>
        <p>In our <a href="https://dangduongminhnhat.github.io/posts/d071024/from-merkel-trees-to-ethereum/">previous exploration</a>, we delved into the foundational structures that underpin decentralized networks. Building on that foundation, this blog focuses on the innovative concepts of zk-Rollups and zkEVMs, technologies poised to revolutionize scalability and efficiency on the Ethereum blockchain. As we navigate through the complexities of these solutions, we’ll uncover how they tackle current limitations and pave the way for a more interconnected decentralized ecosystem.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#scaling-blockchain:-understanding-layer-1-and-layer-2-solutions">Scaling Blockchain: Understanding Layer-1 and Layer-2 Solutions</a>
<ul>
<li><a href="#layer-1-scaling:-enhancing-the-blockchain-itself">Layer-1 Scaling: Enhancing the Blockchain Itself</a>
<ul>
<li><a href="#the-challenge-of-bigger-blocks">The Challenge of Bigger Blocks</a></li>
<li><a href="#sustainable-solutions:-sharding">Sustainable Solutions: Sharding</a></li>
</ul>
</li>
<li><a href="#layer-2-scaling:-offloading-activity-from-the-blockchain">Layer-2 Scaling: Offloading Activity from the Blockchain</a>
<ul>
<li><a href="#how-layer-2-works">How Layer-2 Works</a></li>
<li><a href="#the-benefits-of-layer-2-solutions">The Benefits of Layer-2 Solutions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#unpacking-rollups:-the-future-of-ethereum-scaling">Unpacking Rollups: The Future of Ethereum Scaling</a>
<ul>
<li><a href="#what-are-rollups?">What Are Rollups?</a></li>
<li><a href="#the-mechanics-of-rollups">The Mechanics of Rollups</a>
<ul>
<li><a href="#the-smart-contract">The Smart Contract</a></li>
<li><a href="#batching-transactions">Batching Transactions</a></li>
<li><a href="#deposits-and-withdrawals">Deposits and Withdrawals</a></li>
<li><a href="#ensuring-correctness-of-state-roots">Ensuring Correctness of State Roots</a></li>
</ul>
</li>
<li><a href="#optimistic-rollups-vs.-zk-rollups">Optimistic Rollups vs. ZK Rollups</a>
<ul>
<li><a href="#optimistic-rollups">Optimistic Rollups</a></li>
<li><a href="#zk-rollups">ZK Rollups</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#understanding-zero-knowledge-rollups:-a-deep-dive-into-layer-2-scaling">Understanding Zero-Knowledge Rollups: A Deep Dive into Layer 2 Scaling</a>
<ul>
<li><a href="#what-are-zero-knowledge-rollups?">What Are Zero-Knowledge Rollups?</a></li>
<li><a href="#interacting-with-ethereum:-the-role-of-zk-rollups">Interacting with Ethereum: The Role of ZK-rollups</a>
<ul>
<li><a href="#core-architecture">Core Architecture</a></li>
<li><a href="#the-security-framework-of-zk-rollups">The Security Framework of ZK-rollups</a></li>
</ul>
</li>
<li><a href="#how-zk-rollups-work:-a-step-by-step-guide-to-layer-2-transactions">How ZK-Rollups Work: A Step-by-Step Guide to Layer 2 Transactions</a>
<ul>
<li><a href="#step-1:-user-transactions">Step 1: User Transactions</a></li>
<li><a href="#step-2:-publishing-transaction-data">Step 2: Publishing Transaction Data</a></li>
<li><a href="#step-3:-state-commitments">Step 3: State Commitments</a></li>
<li><a href="#step-4:-validity-proofs">Step 4: Validity Proofs</a>
<ul>
<li><a href="#zk-snarks-vs.-zk-starks">ZK-SNARKs vs. ZK-STARKs</a></li>
</ul>
</li>
<li><a href="#step-5:-proof-generation">Step 5: Proof Generation</a></li>
<li><a href="#step-6:-proof-verification">Step 6: Proof Verification</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#unlocking-the-future-of-ethereum:-the-promise-of-zk-rollups">Unlocking the Future of Ethereum: The Promise of zk-Rollups</a>
<ul>
<li><a href="#the-advantages-of-zk-rollups">The Advantages of zk-Rollups</a>
<ul>
<li><a href="#security-meets-efficiency">Security Meets Efficiency</a></li>
<li><a href="#data-compression">Data Compression</a></li>
</ul>
</li>
<li><a href="#the-current-limitations">The Current Limitations</a>
<ul>
<li><a href="#developer-unfriendliness">Developer Unfriendliness</a></li>
<li><a href="#lack-of-composability">Lack of Composability</a></li>
</ul>
</li>
<li><a href="#the-path-forward:-enhancing-developer-experience">The Path Forward: Enhancing Developer Experience</a>
<ul>
<li><a href="#supporting-native-evm-verification">Supporting Native EVM Verification</a></li>
</ul>
</li>
<li><a href="#two-approaches-to-building-dapps-in-zk-rollups">Two Approaches to Building DApps in zk-Rollups</a>
<ul>
<li><a href="#application-specific-circuits-(asic)">Application-Specific Circuits (ASIC)</a></li>
<li><a href="#universal-evm-circuits">Universal EVM Circuits</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#understanding-zkevm:-the-future-of-ethereum-scaling">Understanding zkEVM: The Future of Ethereum Scaling</a>
<ul>
<li><a href="#what-is-a-zkevm?">What is a zkEVM?</a></li>
<li><a href="#breaking-down-the-definition">Breaking Down the Definition</a>
<ul>
<li><a href="#evm-compatibility">EVM Compatibility</a></li>
<li><a href="#support-for-zero-knowledge-technology">Support for Zero-Knowledge Technology</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-workflow-of-zkevm:-revolutionizing-ethereum-transactions">The Workflow of zkEVM: Revolutionizing Ethereum Transactions</a>
<ul>
<li><a href="#layer-1-vs.-layer-2:-the-basics">Layer 1 vs. Layer 2: The Basics</a>
<ul>
<li><a href="#layer-1:-the-traditional-approach">Layer 1: The Traditional Approach</a></li>
<li><a href="#layer-2:-the-zkevm-advantage">Layer 2: The zkEVM Advantage</a></li>
</ul>
</li>
<li><a href="#deep-dive-into-the-zkevm-execution-process">Deep Dive into the zkEVM Execution Process</a></li>
<li><a href="#the-architecture-of-zkevm">The Architecture of zkEVM</a>
<ul>
<li><a href="#the-execution-environment">The Execution Environment</a></li>
<li><a href="#the-proving-circuit">The Proving Circuit</a></li>
<li><a href="#the-verifier-contract">The Verifier Contract</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#understanding-zkevm-opcodes:-the-building-blocks-of-zero-knowledge-execution">Understanding zkEVM Opcodes: The Building Blocks of Zero-Knowledge Execution</a>
<ul>
<li><a href="#what-are-zkevm-opcodes?">What Are zkEVM Opcodes?</a></li>
<li><a href="#why-do-we-need-zkevm-opcodes?">Why Do We Need zkEVM Opcodes?</a>
<ul>
<li><a href="#the-need-for-efficiency">The Need for Efficiency</a></li>
</ul>
</li>
<li><a href="#approaches-to-creating-zkevm-opcodes">Approaches to Creating zkEVM Opcodes</a>
<ul>
<li><a href="#building-zk-circuits-for-native-evm-opcodes">Building ZK Circuits for Native EVM Opcodes</a></li>
<li><a href="#creating-new-languages-for-zk-proof-computation">Creating New Languages for ZK Proof Computation</a></li>
<li><a href="#the-trade-offs">The Trade-offs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#references">References</a></li>
<li><a href="#connect-with-me">Connect with Me</a></li>
</ul>
<h1 id="scaling-blockchain-understanding-layer-1-and-layer-2-solutions">Scaling Blockchain: Understanding Layer-1 and Layer-2 Solutions</h1>
<p>Blockchain technology has transformed the way we think about trust, transparency, and transactions. However, as the number of users and applications grows, so does the need for increased transaction capacity. To address this, developers are exploring two primary approaches to scaling blockchain ecosystems: Layer-1 and Layer-2 solutions. Let’s dive into these concepts to understand how they work and their implications for the future of blockchain.</p>
<h2 id="layer-1-scaling-enhancing-the-blockchain-itself">Layer-1 Scaling: Enhancing the Blockchain Itself</h2>
<p>Layer-1 scaling involves making changes to the blockchain&rsquo;s core protocol to increase its transaction capacity. The idea is straightforward: if we can make the blockchain handle more transactions per second (TPS), we can alleviate congestion and improve user experience. However, this approach comes with its own set of challenges.</p>
<p><img src="/images/d231024/Layer1.PNG" alt="Line">
<em><a href="https://zk-learning.org/assets/lecture12.pdf">Source Image</a></em></p>
<h3 id="the-challenge-of-bigger-blocks">The Challenge of Bigger Blocks</h3>
<p>One common method for Layer-1 scaling is to increase the block size. While larger blocks can indeed accommodate more transactions, they pose significant verification challenges. As blocks grow larger, they become more difficult to validate. This complexity can lead to a centralization risk, where only a few powerful nodes can afford to process these larger blocks, undermining the very decentralized nature of blockchain.</p>
<h3 id="sustainable-solutions-sharding">Sustainable Solutions: Sharding</h3>
<p>To address these challenges, developers are turning to techniques like <a href="https://ethereum.org/en/developers/docs/scaling/#sharding">sharding</a>. Sharding involves breaking the blockchain into smaller, more manageable pieces (or &ldquo;shards&rdquo;) that can be processed concurrently by multiple nodes. This division of labor increases efficiency and scalability without sacrificing decentralization. Notably, the <a href="https://ethereum.org/en/roadmap/">Eth2</a> upgrade is currently implementing sharding to enhance its transaction capacity.</p>
<h2 id="layer-2-scaling-offloading-activity-from-the-blockchain">Layer-2 Scaling: Offloading Activity from the Blockchain</h2>
<p>While Layer-1 scaling focuses on improving the blockchain itself, Layer-2 scaling takes a different approach. Instead of pushing all activities onto the blockchain, Layer-2 solutions allow users to conduct the bulk of their transactions off-chain. This off-chain processing alleviates congestion on the main blockchain while still leveraging its security features.</p>
<h3 id="how-layer-2-works">How Layer-2 Works</h3>
<p>Layer-2 protocols operate by utilizing a smart contract on the main blockchain. This contract has two main responsibilities:</p>
<ol>
<li><strong>Processing Deposits and Withdrawals:</strong> Users can deposit funds into the Layer-2 protocol and withdraw them back to the Layer-1 blockchain when needed.</li>
<li><strong>Verifying Off-Chain Activity:</strong> The smart contract verifies proofs that the off-chain transactions comply with the established rules.</li>
</ol>
<p>The magic of Layer-2 lies in how these proofs are generated and verified. Various methods exist to create these proofs, but they all share a crucial property: verifying them on-chain is significantly cheaper than executing the original computation off-chain. This efficiency makes Layer-2 solutions appealing for users looking to reduce costs and enhance transaction speeds.</p>
<h3 id="the-benefits-of-layer-2-solutions">The Benefits of Layer-2 Solutions</h3>
<p>Layer-2 scaling solutions offer several advantages:</p>
<ul>
<li><strong>Increased Speed:</strong> With most transactions handled off-chain, users experience faster confirmation times.</li>
<li><strong>Reduced Costs:</strong> By minimizing the on-chain activity, users can save on transaction fees, making blockchain more accessible.</li>
<li><strong>Enhanced Scalability:</strong> Layer-2 can effectively manage a higher volume of transactions, allowing blockchains to support a growing user base and application ecosystem.</li>
</ul>
<h1 id="unpacking-rollups-the-future-of-ethereum-scaling">Unpacking Rollups: The Future of Ethereum Scaling</h1>
<p>As the Ethereum ecosystem expands, the demand for more efficient transaction processing has given rise to innovative solutions known as rollups. These technologies allow existing Ethereum applications to migrate seamlessly with minimal code changes while enhancing scalability. But what exactly are rollups, and how do they work? Let’s break it down.</p>
<h2 id="what-are-rollups">What Are Rollups?</h2>
<p>At their core, rollups are layer-2 scaling solutions designed to process transactions off the main Ethereum blockchain (Layer 1) while leveraging its security. They are fully general-purpose, meaning you can run an Ethereum Virtual Machine (EVM) within a rollup, allowing developers to deploy existing Ethereum applications without extensive rewrites.</p>
<h2 id="the-mechanics-of-rollups">The Mechanics of Rollups</h2>
<p>So, how does a rollup operate? Here’s a step-by-step explanation:</p>
<h3 id="the-smart-contract">The Smart Contract</h3>
<p>A rollup is governed by a smart contract that maintains a <strong>state root</strong>—the Merkle root of the rollup&rsquo;s current state, including account balances, contract code, and other data. This smart contract is pivotal for ensuring the integrity of the rollup’s state.</p>
<p><img src="/images/d231024/diag1.png" alt="Line">
<em><a href="https://vitalik.eth.limo/general/2021/01/05/rollup.html">Source Image</a></em></p>
<h3 id="batching-transactions">Batching Transactions</h3>
<p>Users can submit a <strong>batch</strong>—a collection of transactions packaged together in a compressed format. Each batch includes:</p>
<ul>
<li>The <strong>previous state root</strong> (the state before the transactions in the batch are applied).</li>
<li>The <strong>new state root</strong> (the state after the transactions are processed).</li>
</ul>
<p>When a batch is submitted, the smart contract checks that the previous state root matches the current state root. If everything aligns, the contract updates the state root to the new one.</p>
<p><img src="/images/d231024/diag2.png" alt="Line">
<em><a href="https://vitalik.eth.limo/general/2021/01/05/rollup.html">Source Image</a></em></p>
<h3 id="deposits-and-withdrawals">Deposits and Withdrawals</h3>
<p>To facilitate interactions with assets outside the rollup, the smart contract allows transactions that input or output assets not directly within the rollup’s state. Here’s how it works:</p>
<ul>
<li><strong>Deposits:</strong> If a batch includes transactions that take assets from the outside, the submitting transaction must transfer these assets to the rollup contract.</li>
<li><strong>Withdrawals:</strong> When processing a batch that outputs assets to the outside, the smart contract initiates the corresponding withdrawals.</li>
</ul>
<h3 id="ensuring-correctness-of-state-roots">Ensuring Correctness of State Roots</h3>
<p>A crucial question arises: How do we ensure that the post-state roots in the batches are accurate? If anyone could submit a batch with any post-state root without consequence, they could easily steal funds from the rollup. To address this, there are two distinct approaches leading to two types of rollups: Optimistic Rollups and ZK Rollups.</p>
<h2 id="optimistic-rollups-vs-zk-rollups">Optimistic Rollups vs. ZK Rollups</h2>
<h3 id="optimistic-rollups">Optimistic Rollups</h3>
<p>Optimistic rollups operate on the principle of <strong>fraud proofs</strong>. Here’s how they function:</p>
<ul>
<li>The rollup contract keeps a history of all state roots and the hashes of each batch.</li>
<li>If someone identifies an incorrect post-state root in a submitted batch, they can publish a proof to the chain that demonstrates the error.</li>
<li>The contract verifies this proof and reverts the faulty batch along with all subsequent batches, ensuring the integrity of the rollup.</li>
</ul>
<p>This model relies on the assumption that most transactions are valid, hence the term &ldquo;optimistic.&rdquo;</p>
<h3 id="zk-rollups">ZK Rollups</h3>
<p>In contrast, ZK rollups utilize <strong>validity proofs</strong> to maintain correctness. Every batch submitted includes a cryptographic proof called a <strong>ZK-SNARK</strong> (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge), which confirms that the post-state root is the correct result of executing the transactions in that batch. The benefits of ZK rollups include:</p>
<ul>
<li><strong>Fast Verification:</strong> Regardless of the complexity of the computation, the proof can be quickly verified on-chain, making them highly efficient.</li>
<li><strong>Security:</strong> ZK rollups provide stronger guarantees against fraud because each batch is backed by cryptographic proof.</li>
</ul>
<h1 id="understanding-zero-knowledge-rollups-a-deep-dive-into-layer-2-scaling">Understanding Zero-Knowledge Rollups: A Deep Dive into Layer 2 Scaling</h1>
<p>As the Ethereum ecosystem continues to grow, the demand for faster, more efficient transactions is becoming increasingly urgent. Enter <strong>Zero-Knowledge Rollups (ZK-rollups)</strong>—a revolutionary solution that promises to enhance scalability while maintaining the security and integrity that Ethereum is known for. But what exactly are ZK-rollups, and how do they function? Let’s explore this exciting technology in detail.</p>
<h2 id="what-are-zero-knowledge-rollups">What Are Zero-Knowledge Rollups?</h2>
<p>ZK-rollups are a layer-2 scaling solution that enables the bundling of multiple transactions into a single batch, executed off-chain. This method significantly reduces the amount of data that needs to be posted to the Ethereum blockchain. Instead of sending each transaction individually, ZK-rollup operators submit a summary of the changes required to represent all the transactions in a batch, accompanied by <strong>validity proofs</strong> to ensure the correctness of those changes.</p>
<p><img src="/images/d231024/zkrollup.PNG" alt="Line">
<em><a href="https://zk-learning.org/assets/lecture12.pdf">Source Image</a></em></p>
<h2 id="interacting-with-ethereum-the-role-of-zk-rollups">Interacting with Ethereum: The Role of ZK-rollups</h2>
<p>ZK-rollups operate as an off-chain protocol atop the Ethereum blockchain, managed by smart contracts that ensure the system&rsquo;s integrity. Here’s how the interaction unfolds:</p>
<h3 id="core-architecture">Core Architecture</h3>
<ol>
<li><strong>On-chain Contracts:</strong> The ZK-rollup protocol is controlled by smart contracts on Ethereum. This includes a primary contract that tracks rollup blocks, monitors state updates, and manages deposits. A secondary verifier contract checks the validity proofs submitted by block producers, solidifying Ethereum&rsquo;s role as the foundational layer.</li>
<li><strong>Off-chain Virtual Machine (VM):</strong> While transactions are executed off-chain, they occur in a separate virtual machine independent of the Ethereum Virtual Machine (EVM). This off-chain VM serves as the execution environment for transactions, ensuring efficiency while the validity proofs are ultimately verified on the Ethereum mainnet.</li>
</ol>
<h3 id="the-security-framework-of-zk-rollups">The Security Framework of ZK-rollups</h3>
<p>ZK-rollups are often described as hybrid scaling solutions. They operate independently while relying on Ethereum for security. Here are the critical aspects:</p>
<ul>
<li><strong>Data Availability:</strong> ZK-rollups publish state data for every transaction processed off-chain to Ethereum. This transparency enables users and businesses to reproduce the rollup’s state independently. The data is available to all network participants, ensuring that anyone can verify the rollup&rsquo;s integrity.</li>
<li><strong>Transaction Finality:</strong> Ethereum acts as a settlement layer for ZK-rollups. Transactions on layer 2 are only finalized once the mainnet contract accepts the validity proof, mitigating the risk of malicious operators attempting to corrupt the chain.</li>
<li><strong>Censorship Resistance:</strong> Most ZK-rollups utilize a &ldquo;supernode&rdquo; or operator to execute transactions and produce batches. While this ensures efficiency, it poses a risk of censorship. If users suspect that their transactions are being excluded, they can directly submit transactions to the rollup contract on the mainnet, allowing for an exit without relying on the operator’s consent.</li>
</ul>
<h2 id="how-zk-rollups-work-a-step-by-step-guide-to-layer-2-transactions">How ZK-Rollups Work: A Step-by-Step Guide to Layer 2 Transactions</h2>
<h3 id="step-1-user-transactions">Step 1: User Transactions</h3>
<p>Users start by signing their transactions and submitting them to <strong>Layer 2 (L2) operators</strong> for processing. These operators are responsible for including transactions in the next batch. Depending on the ZK-rollup design, the operator could either be a centralized entity known as a <strong>sequencer</strong>, who handles all transactions, or a decentralized set of operators using a <a href="https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/"><strong>proof-of-stake</strong></a> system.</p>
<p>In the decentralized model, prospective operators deposit funds into the rollup contract. The size of their stake influences their chances of being selected to produce the next rollup batch. If an operator acts maliciously, their stake can be slashed, incentivizing them to maintain the integrity of the network.</p>
<h3 id="step-2-publishing-transaction-data">Step 2: Publishing Transaction Data</h3>
<p>Once transactions are collected, the ZK-rollup operator publishes the transaction data on Ethereum as <strong>calldata</strong>. This area is used to pass arguments to smart contract functions and persists on-chain as part of Ethereum&rsquo;s <a href="https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#logs">history logs</a>. Calldata is a cost-effective way to store transaction data because it doesn&rsquo;t affect Ethereum&rsquo;s state.</p>
<p>The operator calls a function in the rollup contract, passing the compressed transaction data as arguments. This helps minimize storage costs for users since a significant portion of rollup fees is tied to on-chain data storage.</p>
<h3 id="step-3-state-commitments">Step 3: State Commitments</h3>
<p>The state of the ZK-rollup, which includes all Layer 2 accounts and balances, is represented as a <a href="https://dangduongminhnhat.github.io/posts/d071024/from-merkel-trees-to-ethereum/#what-is-a-merkle-tree?"><strong>Merkle tree</strong></a>. The cryptographic hash of this tree’s root, known as the <strong>Merkle root</strong>, is stored in the on-chain contract, allowing the protocol to track changes in the rollup’s state.</p>
<p>When a new batch of transactions is executed, the operator computes a new state root and submits it to the on-chain contract. If the accompanying <strong>validity proof</strong> is authenticated, this new Merkle root becomes the rollup’s canonical state root.</p>
<h3 id="step-4-validity-proofs">Step 4: Validity Proofs</h3>
<p>Before submitting the new state root, the ZK-rollup operator must provide a validity proof that verifies the correctness of the batched transactions. Validity proofs confirm that the proposed changes are valid without revealing the underlying data.</p>
<p>ZK-rollups typically use <strong>ZK-SNARKs</strong> (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge) or <strong>ZK-STARKs</strong> (Zero-Knowledge Scalable Transparent Arguments of Knowledge) for these proofs. Both methods validate off-chain computation while ensuring privacy and security.</p>
<h4 id="zk-snarks-vs-zk-starks">ZK-SNARKs vs. ZK-STARKs</h4>
<ul>
<li><strong>ZK-SNARKs</strong> require a trusted setup for generating public parameters, which can introduce security risks if not handled correctly. However, they produce small proofs and allow for fast verification on-chain.</li>
<li><strong>ZK-STARKs</strong>, on the other hand, do not require a trusted setup and offer better scalability and quantum resistance. They do produce larger proofs, which can be more expensive to verify on Ethereum.</li>
</ul>
<h3 id="step-5-proof-generation">Step 5: Proof Generation</h3>
<p>When the operator has enough transactions, they aggregate them into a batch and compile inputs for the proving circuit, which generates the validity proof. This process involves:</p>
<ol>
<li>Verifying that the sender and receiver accounts are valid.</li>
<li>Ensuring the sender has sufficient funds.</li>
<li>Confirming that the transaction details align with the sender’s public key.</li>
</ol>
<p>The proving circuit loops through each transaction, updating balances and generating new state roots after each transaction is processed. This final Merkle root reflects the rollup&rsquo;s updated state.</p>
<h3 id="step-6-proof-verification">Step 6: Proof Verification</h3>
<p>After the proving circuit has created the validity proof, the L2 operator submits it to the verifier contract on Ethereum. The contract checks:</p>
<ul>
<li>The <strong>pre-state root</strong> (the old state).</li>
<li>The <strong>post-state root</strong> (the new state after transactions).</li>
<li>The <strong>batch root</strong> (the Merkle root of the batch).</li>
<li>The transaction inputs.</li>
</ul>
<p>If everything checks out, the rollup contract updates its state tree to reflect the new state.</p>
<h1 id="unlocking-the-future-of-ethereum-the-promise-of-zk-rollups">Unlocking the Future of Ethereum: The Promise of zk-Rollups</h1>
<p>In the ever-evolving landscape of blockchain technology, <strong>zk-Rollups</strong> have emerged as a frontrunner in scaling solutions for Ethereum. Celebrated for their robust security and swift finalization times, zk-Rollups promise to revolutionize how we think about decentralized applications (DApps) on the Ethereum network. However, despite their advantages, significant hurdles remain for developers looking to leverage this technology fully.</p>
<h2 id="the-advantages-of-zk-rollups">The Advantages of zk-Rollups</h2>
<h3 id="security-meets-efficiency">Security Meets Efficiency</h3>
<p>At the heart of zk-Rollups lies a brilliant concept: aggregating countless transactions into a single Rollup block and generating a succinct proof off-chain. This proof is then submitted to Ethereum&rsquo;s Layer 1, where a smart contract merely needs to verify it. By avoiding the need to re-execute every transaction, zk-Rollups save on gas fees significantly—proof verification is far cheaper than executing computations repeatedly.</p>
<p>As Vitalik Buterin, Ethereum&rsquo;s co-founder, puts it: “<em>In the medium to long term, ZK rollups will win out in all use cases as ZK-SNARK technology improves.</em>” This technology not only makes transactions faster and cheaper but also maintains the security guarantees that Ethereum Layer 1 offers.</p>
<h3 id="data-compression">Data Compression</h3>
<p>Another noteworthy advantage of zk-Rollups is their ability to compress data. By keeping only the essential information on-chain for verification, zk-Rollups ensure that the Ethereum blockchain remains efficient and uncluttered. This allows for a more scalable environment, paving the way for future innovations.</p>
<h2 id="the-current-limitations">The Current Limitations</h2>
<p>Despite these promising features, zk-Rollups currently face significant limitations, particularly in their application scope. At this stage, their usage is largely confined to payments and swaps. The hurdles arise from two primary challenges:</p>
<h3 id="developer-unfriendliness">Developer Unfriendliness</h3>
<p>To build DApps on zk-Rollups, developers must write their smart contract logic in a specialized language known as <strong>R1CS</strong> (Rank-1 Constraint System). Unfortunately, R1CS is not only syntactically complex but also requires an extensive understanding of zero-knowledge proofs. This steep learning curve can deter many developers from exploring zk-Rollup opportunities, thus limiting innovation.</p>
<p><img src="/images/d231024/r1cs.PNG" alt="Line">
<em><a href="https://zk-learning.org/assets/lecture12.pdf">Source Image</a></em></p>
<h3 id="lack-of-composability">Lack of Composability</h3>
<p>Another critical drawback is the absence of composability within zk-Rollups. Composability allows different applications to interact seamlessly within Layer 2, which is vital for creating interconnected DeFi ecosystems. Without this capability, zk-Rollup applications are isolated, significantly undermining the potential for building rich, integrated decentralized finance solutions.</p>
<p><img src="/images/d231024/composability.PNG" alt="Line">
<em><a href="https://zk-learning.org/assets/lecture12.pdf">Source Image</a></em></p>
<h2 id="the-path-forward-enhancing-developer-experience">The Path Forward: Enhancing Developer Experience</h2>
<p>To unlock the full potential of zk-Rollups, it’s essential to address these limitations head-on. The goal is to provide a seamless developer experience and enable composability within Layer 2.</p>
<h3 id="supporting-native-evm-verification">Supporting Native EVM Verification</h3>
<p>One promising solution lies in supporting native EVM (Ethereum Virtual Machine) verification directly within zk-Rollups. By allowing existing Ethereum applications to migrate to zk-Rollups with minimal adjustments, developers can harness the benefits of this scaling solution without needing to learn a new programming language or face the challenges of isolation.</p>
<p>This approach will not only make zk-Rollups more accessible to developers but also encourage a flourishing ecosystem of interconnected DApps. With enhanced composability, DeFi applications can interact more effectively, creating synergies that lead to innovative financial products and services.</p>
<h2 id="two-approaches-to-building-dapps-in-zk-rollups">Two Approaches to Building DApps in zk-Rollups</h2>
<h3 id="application-specific-circuits-asic">Application-Specific Circuits (ASIC)</h3>
<p>The first method involves creating <strong>application-specific circuits</strong>, or ASICs, tailored for individual DApps. This traditional approach leverages zero-knowledge proofs by designing custom circuits that can handle the specific logic and requirements of each application.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>Efficiency:</strong> Customized circuits can optimize performance, reducing overhead for specific DApps.</li>
<li><strong>Tailored Solutions:</strong> Developers can fine-tune the circuit to meet the unique needs of their application.</li>
</ul>
<p><strong>Challenges:</strong></p>
<ul>
<li><strong>Complexity:</strong> Designing ASICs requires significant expertise in circuit design and zero-knowledge proofs, making it less accessible for many developers.</li>
<li><strong>Composability Issues:</strong> Since each circuit is static and specific to a single application, it limits interaction between different DApps, undermining the potential for a cohesive ecosystem.</li>
</ul>
<h3 id="universal-evm-circuits">Universal EVM Circuits</h3>
<p>The second approach proposes building a <strong>universal circuit</strong> based on the Ethereum Virtual Machine (EVM). Instead of creating individual circuits for each DApp, this method focuses on verifying program execution at a lower level, similar to how a CPU operates.</p>
<p><img src="/images/d231024/zkevm.PNG" alt="Line">
<em><a href="https://zk-learning.org/assets/lecture12.pdf">Source Image</a></em></p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>Developer Accessibility:</strong> Developers can write smart contracts using familiar high-level languages without needing to design custom circuits.</li>
<li><strong>Flexibility:</strong> This approach allows for greater composability since any DApp can run on the same universal circuit.</li>
</ul>
<p><strong>Challenges:</strong></p>
<ul>
<li><strong>High Overhead:</strong> One significant drawback is the large computational overhead. For instance, even a simple operation like addition incurs the overhead of an entire EVM circuit. This can lead to inefficiencies, especially with complex DApps requiring numerous execution steps.</li>
</ul>
<h1 id="understanding-zkevm-the-future-of-ethereum-scaling">Understanding zkEVM: The Future of Ethereum Scaling</h1>
<p>As the demand for efficient and scalable solutions on the Ethereum network grows, a new concept has emerged at the forefront of blockchain technology: the <strong>zkEVM</strong>. But what exactly is a zkEVM, and why is it significant?</p>
<h2 id="what-is-a-zkevm">What is a zkEVM?</h2>
<p>At its core, a zkEVM is an <strong>EVM-compatible virtual machine</strong> that incorporates <strong>zero-knowledge proof</strong> computation. Unlike traditional virtual machines, a zkEVM not only executes programs but also proves the correctness of that execution. This includes validating both the inputs and outputs used during operations, ensuring that all processes are accurate and trustworthy.</p>
<h2 id="breaking-down-the-definition">Breaking Down the Definition</h2>
<p>To better understand what a zkEVM is, let’s dissect its two key components:</p>
<h3 id="evm-compatibility">EVM Compatibility</h3>
<p>The <a href="https://dangduongminhnhat.github.io/posts/d071024/from-merkel-trees-to-ethereum/#what-is-the-evm?"><strong>Ethereum Virtual Machine (EVM)</strong></a> is the runtime environment for executing smart contracts on the Ethereum network. Think of it as a “world computer” that allows decentralized applications (dApps) to run seamlessly.</p>
<p>An EVM-compatible virtual machine can execute programs written for the EVM, such as smart contracts developed in <strong>Solidity</strong> or other Ethereum-friendly languages. zkEVMs are designed to be EVM-compatible, which means developers can run existing Ethereum smart contracts with minimal modifications. This compatibility is crucial because it lowers the barrier to entry for developers looking to leverage the benefits of zkEVM technology.</p>
<h3 id="support-for-zero-knowledge-technology">Support for Zero-Knowledge Technology</h3>
<p>While the EVM was never originally designed to support zero-knowledge proofs, recent advancements in research have made it possible to integrate these proofs into EVM computation. This integration is vital as it allows for greater scalability and privacy on the Ethereum network.</p>
<p>Different zkEVM projects employ various approaches to merge EVM execution with zero-knowledge proof computation. Each method comes with its own set of trade-offs, which we’ll delve into later.</p>
<h1 id="the-workflow-of-zkevm-revolutionizing-ethereum-transactions">The Workflow of zkEVM: Revolutionizing Ethereum Transactions</h1>
<p>As Ethereum continues to evolve, understanding the differences between Layer 1 and Layer 2 solutions is crucial for developers and users alike. Enter the <strong>zkEVM</strong>, a cutting-edge approach that enhances transaction efficiency and scalability.</p>
<h2 id="layer-1-vs-layer-2-the-basics">Layer 1 vs. Layer 2: The Basics</h2>
<h3 id="layer-1-the-traditional-approach">Layer 1: The Traditional Approach</h3>
<p>On Layer 1, transactions involve a straightforward but resource-intensive process. Here’s how it works:</p>
<ol>
<li><strong>Storage:</strong> Deployed smart contracts’ bytecodes are stored in Ethereum’s storage.</li>
<li><strong>Broadcasting:</strong> Transactions are broadcasted across a peer-to-peer (P2P) network.</li>
<li><strong>Execution:</strong> Each full node retrieves the corresponding bytecode, executes it on the EVM, and strives to reach the same state based on the transaction input.</li>
</ol>
<p>This method relies on re-executing the smart contract bytecodes, which can be slow and expensive, especially as network congestion increases.</p>
<h3 id="layer-2-the-zkevm-advantage">Layer 2: The zkEVM Advantage</h3>
<p>In contrast, zkEVM introduces a more efficient workflow. Here’s how it operates:</p>
<ol>
<li><strong>Bytecode Storage:</strong> Similar to Layer 1, bytecodes are stored in the same way.</li>
<li><strong>Off-Chain Transactions:</strong> Transactions are sent off-chain to a centralized zkEVM node instead of being executed on every node.</li>
<li><strong>Proof Generation:</strong> Rather than executing bytecode directly, the zkEVM generates a succinct validity proof to confirm that state updates were applied correctly.</li>
<li><strong>Verification on Layer 1:</strong> Finally, this proof is submitted to a Layer 1 contract for verification, allowing the state to be updated without re-executing the transactions.</li>
</ol>
<p>This streamlined process significantly reduces costs and increases speed, making zkEVM a game changer for the Ethereum network.</p>
<h2 id="deep-dive-into-the-zkevm-execution-process">Deep Dive into the zkEVM Execution Process</h2>
<p>The zkEVM’s core strength lies in its ability to generate zero-knowledge proofs that validate various elements of computation. Let&rsquo;s break down what needs to be proven:</p>
<ol>
<li><strong>Bytecode Access</strong>
<ul>
<li><strong>Was the appropriate program code loaded correctly from the right address?</strong>
<ul>
<li>This ensures that the zkEVM is working with the correct bytecode.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Read-Write Operations</strong>
<ul>
<li><strong>Did the program fetch the correct values from the stack, memory, or storage before computation?</strong></li>
<li><strong>Did the program write the correct output values back after execution?</strong>
<ul>
<li>These steps are crucial for maintaining data integrity throughout the transaction process.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Computation</strong>
<ul>
<li><strong>Were the opcodes executed in the correct order without skipping any steps?</strong>
<ul>
<li>Each opcode comprises three sub-steps: reading elements, performing computations, and writing results. Ensuring these are executed accurately is vital for the overall correctness of the transaction.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="the-architecture-of-zkevm">The Architecture of zkEVM</h2>
<p>The zkEVM consists of three integral components: the execution environment, the proving circuit, and the verifier contract. Let’s look at each part in detail.</p>
<h3 id="the-execution-environment">The Execution Environment</h3>
<p>This is where the smart contracts are executed. The zkEVM&rsquo;s execution environment mirrors the EVM’s functionality: it takes the initial state and current transaction, processes them, and outputs a new final state. This ensures that the logic remains consistent with existing Ethereum contracts.</p>
<h3 id="the-proving-circuit">The Proving Circuit</h3>
<p>The proving circuit is responsible for generating the zero-knowledge proofs that validate the transactions computed in the execution environment. Here’s how it works:</p>
<ul>
<li><strong>Input Data:</strong> It uses pre-state information, transaction inputs, and post-state details to create proofs.</li>
<li><strong>Proof Generation:</strong> After processing these inputs, the circuit produces a succinct proof verifying the validity of the state transition.</li>
</ul>
<p><img src="/images/d231024/workflow.PNG" alt="Line">
<em><a href="https://zk-learning.org/assets/lecture12.pdf">Source Image</a></em></p>
<p>This succinct proof is what makes zkEVM efficient and powerful.</p>
<h3 id="the-verifier-contract">The Verifier Contract</h3>
<p>Once the validity proofs are generated, they are submitted to a smart contract deployed on Layer 1 (Ethereum) for verification. Here’s the process:</p>
<ul>
<li><strong>Input Submission:</strong> The pre-states and transaction information are sent to the verifier contract.</li>
<li><strong>Proof Verification:</strong> The contract computes the provided proof, confirming that the outputs were correctly derived from the inputs.</li>
</ul>
<p>This mechanism allows the zkEVM to maintain security and integrity while minimizing the need for costly and time-consuming re-executions.</p>
<h1 id="understanding-zkevm-opcodes-the-building-blocks-of-zero-knowledge-execution">Understanding zkEVM Opcodes: The Building Blocks of Zero-Knowledge Execution</h1>
<p>As the Ethereum ecosystem continues to evolve, zkEVMs (zero-knowledge Ethereum Virtual Machines) are at the forefront of enhancing scalability and privacy on the blockchain. A crucial component of zkEVMs is their opcodes—low-level machine instructions that play a vital role in executing smart contracts efficiently.</p>
<h2 id="what-are-zkevm-opcodes">What Are zkEVM Opcodes?</h2>
<p>At its core, <strong>zkEVM opcodes</strong> are the low-level instructions that zkEVMs use to execute programs in an EVM-compatible environment. Similar to the regular Ethereum Virtual Machine (EVM), contracts written in high-level languages (like Solidity) need to be compiled into bytecode, which specifies the opcodes used when the program is deployed.</p>
<p>However, unlike standard EVM opcodes, zkEVM opcodes are designed specifically to operate efficiently within the constraints of zero-knowledge proof systems. This distinction is essential for ensuring that the performance and security benefits of zk-rollups can be realized without compromising on functionality.</p>
<h2 id="why-do-we-need-zkevm-opcodes">Why Do We Need zkEVM Opcodes?</h2>
<p>Regular EVM opcodes are not optimal for zero-knowledge proving circuits due to their inherent complexity and inefficiency. As zkEVMs aim to validate transactions off-chain while ensuring security on-chain, the design of their opcodes must cater to this unique requirement.</p>
<h3 id="the-need-for-efficiency">The Need for Efficiency</h3>
<p>In a zk-rollup, the goal is to minimize the computational overhead while maximizing the speed of transaction verification. Efficient opcodes help in achieving this by ensuring that the proofs generated for state transitions are succinct and verifiable without unnecessary overhead.</p>
<h2 id="approaches-to-creating-zkevm-opcodes">Approaches to Creating zkEVM Opcodes</h2>
<p>There are primarily two approaches to implementing zkEVM opcodes:</p>
<h3 id="building-zk-circuits-for-native-evm-opcodes">Building ZK Circuits for Native EVM Opcodes</h3>
<p>This approach involves creating zero-knowledge circuits that represent the native EVM opcodes. Here’s a closer look at how this works:</p>
<ul>
<li><strong>Implementation:</strong> Developers must implement all EVM instruction sets within an arithmetic circuit, a process that can be complex and time-consuming.</li>
<li><strong>Benefits:</strong> The primary advantage of this approach is that developers can utilize existing blockchain development tools and easily port existing Ethereum contracts to zk-rollups with minimal modifications. This compatibility fosters a smoother transition for developers who are already familiar with the EVM ecosystem.</li>
</ul>
<h3 id="creating-new-languages-for-zk-proof-computation">Creating New Languages for ZK Proof Computation</h3>
<p>The second approach focuses on designing new programming languages tailored for zero-knowledge proof computation:</p>
<ul>
<li><strong>Custom Opcode Development:</strong> This method requires the development of custom opcodes that can efficiently handle validity proofs.</li>
<li><strong>Direct Writing or Compilation:</strong> Developers can either write smart contracts directly in this new language or compile their Solidity source code into the custom zkEVM opcodes.</li>
</ul>
<p>While this approach can be simpler to implement, it comes with its own set of challenges. For instance, developers may lose access to existing Ethereum infrastructure and tools, making it harder to leverage the rich ecosystem that Ethereum currently offers.</p>
<h3 id="the-trade-offs">The Trade-offs</h3>
<p>Both approaches have their pros and cons. Building ZK circuits for native EVM opcodes may offer better integration with existing tools but can be labor-intensive. Conversely, creating new languages can streamline development but may alienate developers from the established Ethereum ecosystem.</p>
<h1 id="references">References</h1>
<ol>
<li>Vitalik Buterin. (2021, January 05). <em>An Incomplete Guide to Rollups</em>. Retrieved from <a href="https://vitalik.eth.limo/general/2021/01/05/rollup.html">https://vitalik.eth.limo/general/2021/01/05/rollup.html</a></li>
<li><em>Zero-knowledge rollups</em>. Ethereum. Retrieved from: <a href="https://ethereum.org/en/developers/docs/scaling/zk-rollups/">https://ethereum.org/en/developers/docs/scaling/zk-rollups/</a></li>
<li>Ye Zhang@Scroll. (2022, March 15). <em>zkEVM</em>. Retrieved from: <a href="https://hackmd.io/@yezhang/S1_KMMbGt">https://hackmd.io/@yezhang/S1_KMMbGt</a></li>
<li>Alchemy. (2022, June 21). <em>What is a zkEVM?</em> Retrieved from: <a href="https://www.alchemy.com/overviews/zkevm">https://www.alchemy.com/overviews/zkevm</a></li>
</ol>
<h1 id="connect-with-me">Connect with Me</h1>
<p>Connect with me on <a href="https://www.facebook.com/dangduongminhnhat/">Facebook</a>, <a href="https://www.linkedin.com/in/nhatdang1901/">LinkedIn</a>, via email at <a href="mailto:dangduongminhnhat2003@gmail.com">dangduongminhnhat2003@gmail.com</a>, <a href="https://github.com/dangduongminhnhat">GitHub</a>, or by phone at +84829258815.</p>


        
          <div class="blog-tags">
            
              
              <a href="https://dangduongminhnhat.github.io/tags/zkrollups/">zkRollups</a>&nbsp;
            
              
              <a href="https://dangduongminhnhat.github.io/tags/zkevm/">zkEVM</a>&nbsp;
            
              
              <a href="https://dangduongminhnhat.github.io/tags/ethereum/">Ethereum</a>&nbsp;
            
              
              <a href="https://dangduongminhnhat.github.io/tags/blockchain/">Blockchain</a>&nbsp;
            
              
              <a href="https://dangduongminhnhat.github.io/tags/zero-knowledge-proofs/">Zero-Knowledge Proofs</a>&nbsp;
            
          </div>
        

        

        
      </article>
      

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://dangduongminhnhat.github.io/posts/d121024/decoding-cve-2021-22659/" data-toggle="tooltip" data-placement="top" title="Decoding CVE-2021-22659: How to Protect the MicroLogix 1400 from Attacks">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://dangduongminhnhat.github.io/posts/d091124/decoding-stark/" data-toggle="tooltip" data-placement="top" title="Decoding STARK: How to Prove Computation Accuracy Without Revealing the Data">Next Post &rarr;</a>
            </li>
          
        </ul>
      
      <div id="utterances-comments">
          <script src="https://utteranc.es/client.js"
              repo="dangduongminhnhat/dangduongminhnhat.github.io"
              issue-term="pathname"
              theme="github-light"
              crossorigin="anonymous"
              async>
          </script>
      </div>

      

    </div>
  </div>
</div>

      <footer>
  <div class="container">
    
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
        </ul>
        <p class="credits copyright text-muted">
          

          &nbsp;&bull;&nbsp;&copy;
          
            2025
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://dangduongminhnhat.github.io/">Daminha Blog</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="https://gohugo.io">Hugo v0.129.0</a> powered &nbsp;&bull;&nbsp; Theme <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> adapted from <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

<script src="https://dangduongminhnhat.github.io/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://dangduongminhnhat.github.io/js/load-photoswipe.js"></script>










    
  </body>
</html>

